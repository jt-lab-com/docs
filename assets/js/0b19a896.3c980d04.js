"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[989],{635:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"jt-lib/triggers-system","title":"Triggers System","description":"TriggerService manages the triggers system, which automatically executes actions when certain conditions are met. Triggers are integrated with the storage system and can be restored after strategy restart.","source":"@site/docs/jt-lib/triggers-system.md","sourceDirName":"jt-lib","slug":"/jt-lib/triggers-system","permalink":"/docs/docs/jt-lib/triggers-system","draft":false,"unlisted":false,"editUrl":"https://github.com/dev-zone-xs/jt-lab-docs/tree/main/git-docs-en/docs/docs/jt-lib/triggers-system.md","tags":[],"version":"current","frontMatter":{"id":"triggers-system","title":"Triggers System","sidebar_label":"Triggers System"},"sidebar":"tutorialSidebar","previous":{"title":"Exchange Operations (OrdersBasket)","permalink":"/docs/docs/jt-lib/exchange-orders-basket"},"next":{"title":"Market Data","permalink":"/docs/docs/jt-lib/market-data-candles"}}');var i=n(4848),s=n(8453);const a={id:"triggers-system",title:"Triggers System",sidebar_label:"Triggers System"},c="Triggers System",o={},l=[{value:"\u26a0\ufe0f Important: Ways to Register Callbacks",id:"\ufe0f-important-ways-to-register-callbacks",level:2},{value:"1. Direct Callback Passing (Arrow Function)",id:"1-direct-callback-passing-arrow-function",level:3},{value:"2. Callback Registration by Name (Regular Function)",id:"2-callback-registration-by-name-regular-function",level:3},{value:"\ud83d\udd04 Trigger Restoration on Reload",id:"-trigger-restoration-on-reload",level:3},{value:"Trigger Architecture",id:"trigger-architecture",level:2},{value:"Trigger Types",id:"trigger-types",level:2},{value:"Order Triggers",id:"order-triggers",level:3},{value:"Price Triggers",id:"price-triggers",level:3},{value:"Time Triggers",id:"time-triggers",level:3},{value:"Trigger Storage System",id:"trigger-storage-system",level:2},{value:"Trigger Management",id:"trigger-management",level:2},{value:"Handler Registration",id:"handler-registration",level:3},{value:"Task Creation",id:"task-creation",level:3},{value:"Task Cancellation",id:"task-cancellation",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Automatic Stop Loss and Take Profit Management",id:"automatic-stop-loss-and-take-profit-management",level:3},{value:"Price Triggers for Position Entry",id:"price-triggers-for-position-entry",level:3},{value:"Time Triggers for Reports",id:"time-triggers-for-reports",level:3},{value:"Integration with Other Components",id:"integration-with-other-components",level:2},{value:"TriggerService + EventEmitter",id:"triggerservice--eventemitter",level:3},{value:"Storage + Triggers",id:"storage--triggers",level:3},{value:"BaseScript + Triggers",id:"basescript--triggers",level:3},{value:"Next Steps",id:"next-steps",level:2}];function g(r){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...r.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"triggers-system",children:"Triggers System"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"TriggerService"})," manages the triggers system, which automatically executes actions when certain conditions are met. Triggers are integrated with the storage system and can be restored after strategy restart."]}),"\n",(0,i.jsx)(e.h2,{id:"\ufe0f-important-ways-to-register-callbacks",children:"\u26a0\ufe0f Important: Ways to Register Callbacks"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"There are two ways to pass an executable function to a trigger:"})}),"\n",(0,i.jsx)(e.h3,{id:"1-direct-callback-passing-arrow-function",children:"1. Direct Callback Passing (Arrow Function)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// \u2705 Correct - arrow function\r\ntrigger.addTask({\r\n  name: 'myTask',\r\n  triggerPrice: 50000,\r\n  callback: async (args) => {\r\n    log('PriceTrigger', 'Trigger activated!', { args }, true);\r\n  }\r\n});\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-callback-registration-by-name-regular-function",children:"2. Callback Registration by Name (Regular Function)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// \u2705 Correct - regular function registration\r\nclass Script extends BaseScript {\r\n  async onInit() {\r\n    // Register function by name\r\n    this.triggerService.registerHandler('myTask', this.onPriceTrigger, this);\r\n    \r\n    // Add task without callback\r\n    trigger.addTask({\r\n      name: 'myTask',\r\n      triggerPrice: 50000,\r\n      canReStore: true // \u26a0\ufe0f IMPORTANT: only for registered functions!\r\n    });\r\n  }\r\n  \r\n  // Regular function (not arrow!)\r\n  async onPriceTrigger(args: any) {\r\n    log('PriceTrigger', 'Trigger activated!', { args }, true);\r\n  }\r\n}\r\n\r\n// \u274c INCORRECT - arrow functions cannot be registered\r\nclass Script extends BaseScript {\r\n  async onInit() {\r\n    // \u274c Error! Arrow functions are not supported for registration\r\n    this.triggerService.registerHandler('myTask', (args) => {\r\n      log('PriceTrigger', 'This won\\'t work!', { args }, true);\r\n    }, this);\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"-trigger-restoration-on-reload",children:"\ud83d\udd04 Trigger Restoration on Reload"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Key Difference:"})," Only registered callbacks can be restored when the script is reloaded!"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"Registered functions"})," (",(0,i.jsx)(e.code,{children:"canReStore: true"}),") \u2014 restored automatically"]}),"\n",(0,i.jsxs)(e.li,{children:["\u274c ",(0,i.jsx)(e.strong,{children:"Arrow functions"})," \u2014 NOT restored on reload"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"trigger-architecture",children:"Trigger Architecture"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Centralized Management"})," - all triggers are managed through ",(0,i.jsx)(e.code,{children:"TriggerService"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Automatic Storage"})," - trigger state is saved in Storage"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Restoration After Restart"})," - triggers automatically restore their state"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Event Integration"})," - triggers subscribe to appropriate events"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"trigger-types",children:"Trigger Types"}),"\n",(0,i.jsx)(e.h3,{id:"order-triggers",children:"Order Triggers"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"OrderTrigger"})," executes actions when order status changes."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Key Features:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"React to order status changes (open, filled, canceled)"}),"\n",(0,i.jsxs)(e.li,{children:["Support for both ",(0,i.jsx)(e.code,{children:"orderId"})," and ",(0,i.jsx)(e.code,{children:"clientOrderId"})]}),"\n",(0,i.jsx)(e.li,{children:"Automatic task lifecycle management"}),"\n",(0,i.jsx)(e.li,{children:"Storage system integration"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Usage Examples:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// Register handler\r\nglobals.triggers.registerOrderHandler('createSlTp', this.createSlTp, this);\r\n\r\n// Create task\r\nglobals.triggers.addTaskByOrder({\r\n  name: 'createSlTp',\r\n  orderId: '12345',\r\n  status: 'closed',\r\n  canReStore: true\r\n});\n"})}),"\n",(0,i.jsx)(e.h3,{id:"price-triggers",children:"Price Triggers"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"PriceTrigger"})," executes actions when certain price levels are reached."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Key Features:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Support for trigger directions (UpToDown, DownToUp)"}),"\n",(0,i.jsx)(e.li,{children:"Automatic direction detection based on current price"}),"\n",(0,i.jsx)(e.li,{children:"Performance optimization through min/max prices"}),"\n",(0,i.jsx)(e.li,{children:"Multiple symbol support"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Trigger Directions:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.code,{children:"UpToDown"})})," - triggers when price falls to specified level"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.code,{children:"DownToUp"})})," - triggers when price rises to specified level"]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Automatic Direction Selection:"}),"\r\nIf direction is not specified, the system automatically determines it based on current price:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["If current price is ",(0,i.jsx)(e.strong,{children:"above"})," trigger price \u2192 ",(0,i.jsx)(e.code,{children:"UpToDown"})," is selected"]}),"\n",(0,i.jsxs)(e.li,{children:["If current price is ",(0,i.jsx)(e.strong,{children:"below"})," trigger price \u2192 ",(0,i.jsx)(e.code,{children:"DownToUp"})," is selected"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Usage Examples:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"import { PriceTriggerDirection } from 'jt-lib';\r\n\r\n// 1. Automatic direction selection\r\nglobals.triggers.addTaskByPrice({\r\n  symbol: 'BTC/USDT',\r\n  name: 'autoDirection',\r\n  triggerPrice: 50000, // Direction will be selected automatically\r\n  canReStore: true\r\n});\r\n\r\n// 2. Explicit direction - triggers on price rise\r\nglobals.triggers.addTaskByPrice({\r\n  symbol: 'BTC/USDT',\r\n  name: 'sellOnRise',\r\n  triggerPrice: 55000,\r\n  direction: PriceTriggerDirection.DownToUp, // Triggers on rise\r\n  canReStore: true\r\n});\r\n\r\n// 3. Explicit direction - triggers on price fall\r\nglobals.triggers.addTaskByPrice({\r\n  symbol: 'BTC/USDT',\r\n  name: 'buyOnFall',\r\n  triggerPrice: 45000,\r\n  direction: PriceTriggerDirection.UpToDown, // Triggers on fall\r\n  canReStore: true\r\n});\r\n\r\n// Register handlers\r\nglobals.triggers.registerPriceHandler('BTC/USDT', 'sellOnRise', this.onPriceRise, this);\r\nglobals.triggers.registerPriceHandler('BTC/USDT', 'buyOnFall', this.onPriceFall, this);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"time-triggers",children:"Time Triggers"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"TimeTrigger"})," executes actions at specific times or with given intervals."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Key Features:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Execute tasks at specific times"}),"\n",(0,i.jsx)(e.li,{children:"Recurring tasks with given intervals"}),"\n",(0,i.jsx)(e.li,{children:"Automatic trigger time validation"}),"\n",(0,i.jsx)(e.li,{children:"Warnings for incorrect time parameters"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Usage Examples:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// Register handler\r\nglobals.triggers.registerTimeHandler('dailyReport', this.generateDailyReport, this);\r\n\r\n// Create task for specific time\r\nglobals.triggers.addTaskByTime({\r\n  name: 'dailyReport',\r\n  triggerTime: Date.now() + 24 * 60 * 60 * 1000, // tomorrow\r\n  canReStore: true\r\n});\r\n\r\n// Recurring task\r\nglobals.triggers.addTaskByTime({\r\n  name: 'hourlyCheck',\r\n  triggerTime: Date.now() + 60 * 60 * 1000, // in an hour\r\n  interval: 60 * 60 * 1000, // repeat every hour\r\n  canReStore: true\r\n});\n"})}),"\n",(0,i.jsx)(e.h2,{id:"trigger-storage-system",children:"Trigger Storage System"}),"\n",(0,i.jsx)(e.p,{children:"All triggers support automatic saving and restoration:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.code,{children:"canReStore: true"})})," - trigger will be saved to Storage"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Automatic Restoration"})," - when strategy restarts, triggers restore their state"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Persistence"})," - tasks continue working after restart"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"trigger-management",children:"Trigger Management"}),"\n",(0,i.jsx)(e.h3,{id:"handler-registration",children:"Handler Registration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// Register handlers for all trigger types\r\nglobals.triggers.registerOrderHandler('taskName', this.handler, this);\r\nglobals.triggers.registerPriceHandler('BTC/USDT', 'taskName', this.handler, this);\r\nglobals.triggers.registerTimeHandler('taskName', this.handler, this);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"task-creation",children:"Task Creation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// Create tasks for each trigger type\r\nconst orderTaskId = globals.triggers.addTaskByOrder({...});\r\nconst priceTaskId = globals.triggers.addTaskByPrice({...});\r\nconst timeTaskId = globals.triggers.addTaskByTime({...});\n"})}),"\n",(0,i.jsx)(e.h3,{id:"task-cancellation",children:"Task Cancellation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// Cancel specific task\r\nglobals.triggers.cancelOrderTask(orderTaskId);\r\nglobals.triggers.cancelPriceTask(priceTaskId);\r\nglobals.triggers.cancelTimeTask(timeTaskId);\n"})}),"\n",(0,i.jsx)(e.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,i.jsx)(e.h3,{id:"automatic-stop-loss-and-take-profit-management",children:"Automatic Stop Loss and Take Profit Management"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"class Script extends BaseScript {\r\n  async onInit() {\r\n    // Register handler for creating SL/TP\r\n    globals.triggers.registerOrderHandler('createSlTp', this.createSlTp, this);\r\n    \r\n    this.basket = new OrdersBasket({\r\n      symbol: this.symbols[0],\r\n      connectionName: this.connectionName\r\n    });\r\n    await this.basket.init();\r\n  }\r\n\r\n  async onTick() {\r\n    const price = this.basket.close();\r\n    \r\n    // Create order with automatic SL/TP\r\n    const order = await this.basket.buyMarket(\r\n      this.basket.getContractsAmount(100, price),\r\n      0, // SL will be set automatically\r\n      0  // TP will be set automatically\r\n    );\r\n\r\n    // Create task for automatic SL/TP creation\r\n    globals.triggers.addTaskByOrder({\r\n      name: 'createSlTp',\r\n      orderId: order.id,\r\n      status: 'closed', // will execute when order is filled\r\n      canReStore: true\r\n    });\r\n  }\r\n\r\n  async createSlTp(orderId: string) {\r\n    // Get order information\r\n    const order = await this.basket.getOrder(orderId);\r\n    \r\n    if (order && order.status === 'closed') {\r\n      const currentPrice = this.basket.close();\r\n      const slPrice = currentPrice * 0.95; // SL 5% below\r\n      const tpPrice = currentPrice * 1.1;  // TP 10% above\r\n      \r\n      // Create SL and TP orders\r\n      await this.basket.createStopLossOrder('buy', order.amount, slPrice);\r\n      await this.basket.createTakeProfitOrder('buy', order.amount, tpPrice);\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"price-triggers-for-position-entry",children:"Price Triggers for Position Entry"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"class Script extends BaseScript {\r\n  async onInit() {\r\n    // Register handler for position entry\r\n    globals.triggers.registerPriceHandler('BTC/USDT', 'enterLong', this.enterLong, this);\r\n    globals.triggers.registerPriceHandler('BTC/USDT', 'enterShort', this.enterShort, this);\r\n    \r\n    this.basket = new OrdersBasket({\r\n      symbol: this.symbols[0],\r\n      connectionName: this.connectionName\r\n    });\r\n    await this.basket.init();\r\n    \r\n    const currentPrice = this.basket.close();\r\n    \r\n    // Create triggers for position entry\r\n    globals.triggers.addTaskByPrice({\r\n      symbol: 'BTC/USDT',\r\n      name: 'enterLong',\r\n      triggerPrice: currentPrice * 0.98, // entry 2% below current price\r\n      direction: 'DownToUp',\r\n      canReStore: true\r\n    });\r\n    \r\n    globals.triggers.addTaskByPrice({\r\n      symbol: 'BTC/USDT',\r\n      name: 'enterShort',\r\n      triggerPrice: currentPrice * 1.02, // entry 2% above current price\r\n      direction: 'UpToDown',\r\n      canReStore: true\r\n    });\r\n  }\r\n\r\n  async enterLong() {\r\n    const price = this.basket.close();\r\n    const contracts = this.basket.getContractsAmount(100, price);\r\n    \r\n    await this.basket.buyMarket(contracts, price * 0.95, price * 1.1);\r\n    log('PositionManager', 'Long position opened', { price, contracts }, true);\r\n  }\r\n\r\n  async enterShort() {\r\n    const price = this.basket.close();\r\n    const contracts = this.basket.getContractsAmount(100, price);\r\n    \r\n    await this.basket.sellMarket(contracts, price * 1.05, price * 0.9);\r\n    log('PositionManager', 'Short position opened', { price, contracts }, true);\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"time-triggers-for-reports",children:"Time Triggers for Reports"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"class Script extends BaseScript {\r\n  async onInit() {\r\n    // Register handler for daily reports\r\n    globals.triggers.registerTimeHandler('dailyReport', this.generateDailyReport, this);\r\n    globals.triggers.registerTimeHandler('hourlyCheck', this.hourlyCheck, this);\r\n    \r\n    this.basket = new OrdersBasket({\r\n      symbol: this.symbols[0],\r\n      connectionName: this.connectionName\r\n    });\r\n    await this.basket.init();\r\n    \r\n    // Create daily report at 00:00\r\n    const tomorrow = new Date();\r\n    tomorrow.setDate(tomorrow.getDate() + 1);\r\n    tomorrow.setHours(0, 0, 0, 0);\r\n    \r\n    globals.triggers.addTaskByTime({\r\n      name: 'dailyReport',\r\n      triggerTime: tomorrow.getTime(),\r\n      interval: 24 * 60 * 60 * 1000, // repeat every day\r\n      canReStore: true\r\n    });\r\n    \r\n    // Create hourly check\r\n    globals.triggers.addTaskByTime({\r\n      name: 'hourlyCheck',\r\n      triggerTime: Date.now() + 60 * 60 * 1000, // in an hour\r\n      interval: 60 * 60 * 1000, // repeat every hour\r\n      canReStore: true\r\n    });\r\n  }\r\n\r\n  async generateDailyReport() {\r\n    const positions = await this.basket.getPositions();\r\n    const orders = await this.basket.getOrders();\r\n    \r\n    log('DailyReport', '=== Daily Report ===', {}, true);\r\n    log('DailyReport', 'Positions count', { count: positions.length }, true);\r\n    log('DailyReport', 'Orders count', { count: orders.length }, true);\r\n    log('DailyReport', 'Current P&L', { pnl: positions.reduce((sum, pos) => sum + pos.unrealizedPnl, 0) }, true);\r\n  }\r\n\r\n  async hourlyCheck() {\r\n    const price = this.basket.close();\r\n    log('HourlyCheck', 'Hourly check - Current price', { price }, true);\r\n    \r\n    // Check trading conditions\r\n    if (price > 50000) {\r\n      log('HourlyCheck', 'Price above 50k - consider taking profit', { price }, true);\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"integration-with-other-components",children:"Integration with Other Components"}),"\n",(0,i.jsx)(e.h3,{id:"triggerservice--eventemitter",children:"TriggerService + EventEmitter"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"TriggerService subscribes to events through EventEmitter"}),"\n",(0,i.jsx)(e.li,{children:"Automatic lifecycle synchronization"}),"\n",(0,i.jsx)(e.li,{children:"Full typing of all handlers"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"storage--triggers",children:"Storage + Triggers"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Triggers automatically save their state"}),"\n",(0,i.jsx)(e.li,{children:"When strategy restarts, state is restored"}),"\n",(0,i.jsx)(e.li,{children:"Ensures automation continuity"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"basescript--triggers",children:"BaseScript + Triggers"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Strategy registers trigger handlers"}),"\n",(0,i.jsx)(e.li,{children:"Automatic subscription management on destruction"}),"\n",(0,i.jsx)(e.li,{children:"Event system integration for automation"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.a,{href:"/docs/jt-lib/events-system",children:"Event System"})})," - EventEmitter for event management"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.a,{href:"/docs/jt-lib/trading-scripts",children:"Trading Scripts"})})," - Base class for trading scripts"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.a,{href:"/docs/jt-lib/exchange-orders-basket",children:"Exchange Operations"})})," - OrdersBasket for trading operations"]}),"\n"]})]})}function d(r={}){const{wrapper:e}={...(0,s.R)(),...r.components};return e?(0,i.jsx)(e,{...r,children:(0,i.jsx)(g,{...r})}):g(r)}},8453:(r,e,n)=>{n.d(e,{R:()=>a,x:()=>c});var t=n(6540);const i={},s=t.createContext(i);function a(r){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function c(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(i):r.components||i:a(r.components),t.createElement(s.Provider,{value:e},r.children)}}}]);