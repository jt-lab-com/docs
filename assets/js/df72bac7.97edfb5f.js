"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[59],{1367:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>f,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"jt-lib/market-data-candles","title":"Market Data (Candles)","description":"JT-LIB provides a powerful system for working with market data, including historical candle retrieval, data buffering, and market analysis. The system is built around CandlesBuffer for efficient data management and getHistory for historical data retrieval.","source":"@site/docs/jt-lib/market-data-candles.md","sourceDirName":"jt-lib","slug":"/jt-lib/market-data-candles","permalink":"/docs/docs/jt-lib/market-data-candles","draft":false,"unlisted":false,"editUrl":"https://github.com/dev-zone-xs/jt-lab-docs/tree/main/git-docs-en/docs/docs/jt-lib/market-data-candles.md","tags":[],"version":"current","frontMatter":{"id":"market-data-candles","title":"Market Data (Candles)","sidebar_label":"Market Data"},"sidebar":"tutorialSidebar","previous":{"title":"Triggers System","permalink":"/docs/docs/jt-lib/triggers-system"},"next":{"title":"Technical Indicators","permalink":"/docs/docs/jt-lib/technical-indicators"}}');var s=t(4848),a=t(8453);const i={id:"market-data-candles",title:"Market Data (Candles)",sidebar_label:"Market Data"},l="Market Data (Candles)",c={},d=[{value:"Getting Candles - Historical Data",id:"getting-candles---historical-data",level:2},{value:"getHistory Function",id:"gethistory-function",level:3},{value:"Usage Examples",id:"usage-examples",level:3},{value:"Candle Data Format",id:"candle-data-format",level:3},{value:"CandlesBuffer - Data Buffering",id:"candlesbuffer---data-buffering",level:2},{value:"Key Features",id:"key-features",level:3},{value:"Getting Buffer Through Global Service",id:"getting-buffer-through-global-service",level:3},{value:"CandlesBufferOptions Parameters",id:"candlesbufferoptions-parameters",level:3},{value:"How Caching Works",id:"how-caching-works",level:3},{value:"CandlesBuffer Methods",id:"candlesbuffer-methods",level:3},{value:"Time Intervals - Working with Timeframes",id:"time-intervals---working-with-timeframes",level:2},{value:"Supported Timeframes",id:"supported-timeframes",level:3},{value:"Timeframe Conversion",id:"timeframe-conversion",level:3},{value:"Time Rounding by Timeframe",id:"time-rounding-by-timeframe",level:3},{value:"Market Data Processing - How to Analyze Market",id:"market-data-processing---how-to-analyze-market",level:2},{value:"CandlesBufferService - Global Buffer Management",id:"candlesbufferservice---global-buffer-management",level:3},{value:"Integration with Indicators",id:"integration-with-indicators",level:3},{value:"Practical Analysis Examples",id:"practical-analysis-examples",level:3},{value:"Simple Trend Analysis",id:"simple-trend-analysis",level:4},{value:"Volatility Analysis",id:"volatility-analysis",level:4},{value:"Support and Resistance",id:"support-and-resistance",level:4},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Buffer Size Management",id:"buffer-size-management",level:4},{value:"Automatic Buffer Caching",id:"automatic-buffer-caching",level:4},{value:"Integration with Other Components",id:"integration-with-other-components",level:2},{value:"BaseScript + CandlesBuffer",id:"basescript--candlesbuffer",level:3},{value:"OrdersBasket + Market Data",id:"ordersbasket--market-data",level:3},{value:"Next Steps",id:"next-steps",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"market-data-candles",children:"Market Data (Candles)"})}),"\n",(0,s.jsxs)(n.p,{children:["JT-LIB provides a powerful system for working with market data, including historical candle retrieval, data buffering, and market analysis. The system is built around ",(0,s.jsx)(n.code,{children:"CandlesBuffer"})," for efficient data management and ",(0,s.jsx)(n.code,{children:"getHistory"})," for historical data retrieval."]}),"\n",(0,s.jsx)(n.h2,{id:"getting-candles---historical-data",children:"Getting Candles - Historical Data"}),"\n",(0,s.jsx)(n.h3,{id:"gethistory-function",children:"getHistory Function"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"getHistory"})})," is the main function for retrieving historical candle data."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"getHistory(symbol: string, timeframe: TimeFrame, startTime: number, limit?: number): Promise<OHLC[]>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"symbol"})," \u2014 trading symbol (e.g., 'BTC/USDT')"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"timeframe"})," \u2014 candle timeframe ('1m', '5m', '15m', '1h', '4h', '1d', '1w', '1M')"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"startTime"})," \u2014 start time in milliseconds"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"limit"})," \u2014 number of candles (default: maximum available)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," Array of candles in format ",(0,s.jsx)(n.code,{children:"[timestamp, open, high, low, close, volume]"})]}),"\n",(0,s.jsx)(n.h3,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Get last 100 candles for 1 hour\nconst timeFrom = tms() - 1000 * 60 * 60 * 24 * 7; // 7 days ago\nconst candles = await getHistory('BTC/USDT', '1h', timeFrom, 100);\n\n// Get daily candles for last month\nconst monthAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;\nconst dailyCandles = await getHistory('ETH/USDT', '1d', monthAgo, 30);\n\n// Get minute candles for analysis\nconst minuteCandles = await getHistory('BTC/USDT', '1m', Date.now() - 60 * 60 * 1000, 60);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"candle-data-format",children:"Candle Data Format"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Each candle is represented as an array:\ntype OHLC = [number, number, number, number, number, number];\n// [timestamp, open, high, low, close, volume]\n\n// Example:\nconst candle = [1614556800000, 50000, 51000, 49000, 50500, 1000];\n// timestamp: 1614556800000 (candle open time)\n// open: 50000 (open price)\n// high: 51000 (maximum price)\n// low: 49000 (minimum price)\n// close: 50500 (close price)\n// volume: 1000 (trading volume)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"candlesbuffer---data-buffering",children:"CandlesBuffer - Data Buffering"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"CandlesBuffer"})})," is a class for efficient candle buffer management with automatic updates. In JT-LIB, buffers are managed through the global ",(0,s.jsx)(n.code,{children:"CandlesBufferService"}),", which prevents creating duplicate buffers for the same symbol and timeframe combinations."]}),"\n",(0,s.jsx)(n.h3,{id:"key-features",children:"Key Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Global Caching"})," \u2014 one buffer per symbol+timeframe combination"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Updates"})," \u2014 subscription to ",(0,s.jsx)(n.code,{children:"onTick"})," events for data updates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data Preloading"})," \u2014 automatic historical data loading on initialization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Buffer Size Management"})," \u2014 limiting maximum buffer size"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"OHLC Data Access"})," \u2014 methods for getting open, high, low, close, volume"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"getting-buffer-through-global-service",children:"Getting Buffer Through Global Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Get buffer through global service (recommended way)\nconst buffer = await globals.candlesBufferService.getBuffer({\n  symbol: 'BTC/USDT',\n  timeframe: '1h',\n  preloadCandlesCount: 250, // number of candles to preload\n  maxBufferLength: 1000     // maximum buffer size\n});\n\n// Buffer is automatically initialized and cached\n// On repeated request with same parameters, existing buffer is returned\n"})}),"\n",(0,s.jsx)(n.h3,{id:"candlesbufferoptions-parameters",children:"CandlesBufferOptions Parameters"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface CandlesBufferOptions {\n  symbol: string;                    // trading symbol\n  timeframe: string | number;        // timeframe\n  preloadCandlesCount?: number;      // number of candles to preload (default: 250)\n  maxBufferLength?: number;          // maximum buffer size (default: 1000)\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"how-caching-works",children:"How Caching Works"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"CandlesBufferService"})," creates a unique key for each buffer: ",(0,s.jsx)(n.code,{children:"${symbol}-${timeframe}"}),". On first request, a new buffer is created; on repeated requests with the same parameters, the existing buffer is returned."]}),"\n",(0,s.jsx)(n.h3,{id:"candlesbuffer-methods",children:"CandlesBuffer Methods"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Get all candles\nconst candles = buffer.getCandles();\n\n// Get specific candle (shift = 0 - last candle)\nconst lastCandle = buffer.getCandle(0);\nconst prevCandle = buffer.getCandle(1);\n\n// Get OHLC data of last candle\nconst close = buffer.close();\nconst high = buffer.high();\nconst low = buffer.low();\nconst open = buffer.open();\nconst volume = buffer.volume();\nconst timestamp = buffer.tms();\n\n// Clear buffer\nbuffer.clear();\n\n// Get last update time\nconst lastUpdate = buffer.getLastTimeUpdated();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"time-intervals---working-with-timeframes",children:"Time Intervals - Working with Timeframes"}),"\n",(0,s.jsx)(n.h3,{id:"supported-timeframes",children:"Supported Timeframes"}),"\n",(0,s.jsx)(n.p,{children:"JT-LIB supports the following timeframes:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Timeframe"}),(0,s.jsx)(n.th,{children:"Minutes"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'1m'"})}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"1 minute"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'5m'"})}),(0,s.jsx)(n.td,{children:"5"}),(0,s.jsx)(n.td,{children:"5 minutes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'15m'"})}),(0,s.jsx)(n.td,{children:"15"}),(0,s.jsx)(n.td,{children:"15 minutes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'1h'"})}),(0,s.jsx)(n.td,{children:"60"}),(0,s.jsx)(n.td,{children:"1 hour"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'4h'"})}),(0,s.jsx)(n.td,{children:"240"}),(0,s.jsx)(n.td,{children:"4 hours"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'1d'"})}),(0,s.jsx)(n.td,{children:"1440"}),(0,s.jsx)(n.td,{children:"1 day"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'1w'"})}),(0,s.jsx)(n.td,{children:"10080"}),(0,s.jsx)(n.td,{children:"1 week"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'1M'"})}),(0,s.jsx)(n.td,{children:"43200"}),(0,s.jsx)(n.td,{children:"1 month"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"timeframe-conversion",children:"Timeframe Conversion"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { convertTimeframeToString, convertTimeframeToNumber } from 'jt-lib';\n\n// Convert to string\nconst tfString = convertTimeframeToString(60); // '1h'\nconst tfString2 = convertTimeframeToString('m60'); // '1h'\n\n// Convert to number (minutes)\nconst tfNumber = convertTimeframeToNumber('1h'); // 60\nconst tfNumber2 = convertTimeframeToNumber('1d'); // 1440\n"})}),"\n",(0,s.jsx)(n.h3,{id:"time-rounding-by-timeframe",children:"Time Rounding by Timeframe"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { roundTimeByTimeframe } from 'jt-lib';\n\nconst timestamp = Date.now();\nconst roundedTime = roundTimeByTimeframe(timestamp, '1h');\n// Rounds time to start of hour\n"})}),"\n",(0,s.jsx)(n.h2,{id:"market-data-processing---how-to-analyze-market",children:"Market Data Processing - How to Analyze Market"}),"\n",(0,s.jsx)(n.h3,{id:"candlesbufferservice---global-buffer-management",children:"CandlesBufferService - Global Buffer Management"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"CandlesBufferService"})})," is a global service for managing candle buffers. The service is automatically created in ",(0,s.jsx)(n.code,{children:"BaseScript"})," and accessible through ",(0,s.jsx)(n.code,{children:"globals.candlesBufferService"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Get buffer through global service\nconst buffer = await globals.candlesBufferService.getBuffer({\n  symbol: 'BTC/USDT',\n  timeframe: '1h',\n  preloadCandlesCount: 500\n});\n\n// Service automatically manages buffer caching\n// Buffers are created by key: `${symbol}-${timeframe}`\n// On repeated request with same parameters, existing buffer is returned\n"})}),"\n",(0,s.jsx)(n.h3,{id:"integration-with-indicators",children:"Integration with Indicators"}),"\n",(0,s.jsx)(n.p,{children:"CandlesBuffer integrates with the indicator system:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { BaseIndicator } from 'jt-lib';\n\nclass MyIndicator extends BaseIndicator {\n  constructor(symbol: string, timeframe: TimeFrame, buffer: CandlesBuffer) {\n    super(symbol, timeframe, buffer);\n  }\n\n  calculate() {\n    const candles = this.candlesBuffer.getCandles();\n    // Indicator calculation logic\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"practical-analysis-examples",children:"Practical Analysis Examples"}),"\n",(0,s.jsx)(n.h4,{id:"simple-trend-analysis",children:"Simple Trend Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  private buffer: CandlesBuffer;\n\n  async onInit() {\n    // Get buffer through global service\n    this.buffer = await globals.candlesBufferService.getBuffer({\n      symbol: this.symbols[0],\n      timeframe: '1h',\n      preloadCandlesCount: 100\n    });\n  }\n\n  async onTick() {\n    const candles = this.buffer.getCandles();\n    \n    if (candles.length < 20) return;\n\n    // Trend analysis on last 20 candles\n    const recentCandles = candles.slice(-20);\n    const avgHigh = recentCandles.reduce((sum, c) => sum + c.high, 0) / 20;\n    const avgLow = recentCandles.reduce((sum, c) => sum + c.low, 0) / 20;\n    \n    const currentPrice = this.buffer.close();\n    \n    if (currentPrice > avgHigh) {\n      log('TrendAnalysis', 'Uptrend', { currentPrice, avgHigh, avgLow }, true);\n    } else if (currentPrice < avgLow) {\n      log('TrendAnalysis', 'Downtrend', { currentPrice, avgHigh, avgLow }, true);\n    } else {\n      log('TrendAnalysis', 'Sideways movement', { currentPrice, avgHigh, avgLow }, true);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"volatility-analysis",children:"Volatility Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  private buffer: CandlesBuffer;\n\n  async onInit() {\n    // Get buffer through global service\n    this.buffer = await globals.candlesBufferService.getBuffer({\n      symbol: this.symbols[0],\n      timeframe: '4h',\n      preloadCandlesCount: 50\n    });\n  }\n\n  async onTick() {\n    const candles = this.buffer.getCandles();\n    \n    if (candles.length < 10) return;\n\n    // Volatility calculation\n    const recentCandles = candles.slice(-10);\n    const volatilities = recentCandles.map(candle => \n      (candle.high - candle.low) / candle.close\n    );\n    \n    const avgVolatility = volatilities.reduce((sum, v) => sum + v, 0) / 10;\n    \n    log('VolatilityAnalysis', `Average volatility: ${(avgVolatility * 100).toFixed(2)}%`, { avgVolatility }, true);\n    \n    if (avgVolatility > 0.05) {\n      log('VolatilityAnalysis', 'High volatility', { avgVolatility }, true);\n    } else if (avgVolatility < 0.02) {\n      log('VolatilityAnalysis', 'Low volatility', { avgVolatility }, true);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"support-and-resistance",children:"Support and Resistance"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  private buffer: CandlesBuffer;\n\n  async onInit() {\n    // Get buffer through global service\n    this.buffer = await globals.candlesBufferService.getBuffer({\n      symbol: this.symbols[0],\n      timeframe: '1d',\n      preloadCandlesCount: 100\n    });\n  }\n\n  async onTick() {\n    const candles = this.buffer.getCandles();\n    \n    if (candles.length < 50) return;\n\n    // Find support and resistance levels\n    const highs = candles.map(c => c.high);\n    const lows = candles.map(c => c.low);\n    \n    const resistance = Math.max(...highs.slice(-20));\n    const support = Math.min(...lows.slice(-20));\n    \n    const currentPrice = this.buffer.close();\n    \n    log('SupportResistance', `Support: ${support}, Resistance: ${resistance}`, { support, resistance, currentPrice }, true);\n    \n    if (currentPrice > resistance * 0.99) {\n      log('SupportResistance', 'Resistance breakout', { currentPrice, resistance }, true);\n    } else if (currentPrice < support * 1.01) {\n      log('SupportResistance', 'Support breakout', { currentPrice, support }, true);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.h4,{id:"buffer-size-management",children:"Buffer Size Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// For long-term analysis use large buffers\nconst longTermBuffer = await globals.candlesBufferService.getBuffer({\n  symbol: 'BTC/USDT',\n  timeframe: '1d',\n  preloadCandlesCount: 1000,\n  maxBufferLength: 2000\n});\n\n// For short-term analysis - smaller buffers\nconst shortTermBuffer = await globals.candlesBufferService.getBuffer({\n  symbol: 'BTC/USDT',\n  timeframe: '1m',\n  preloadCandlesCount: 100,\n  maxBufferLength: 500\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"automatic-buffer-caching",children:"Automatic Buffer Caching"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  private hourlyBuffer: CandlesBuffer;\n  private dailyBuffer: CandlesBuffer;\n\n  async onInit() {\n    // Buffers are automatically cached through global service\n    // On repeated request with same parameters, existing buffer is returned\n    this.hourlyBuffer = await globals.candlesBufferService.getBuffer({\n      symbol: this.symbols[0],\n      timeframe: '1h'\n    });\n    \n    this.dailyBuffer = await globals.candlesBufferService.getBuffer({\n      symbol: this.symbols[0],\n      timeframe: '1d'\n    });\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-other-components",children:"Integration with Other Components"}),"\n",(0,s.jsx)(n.h3,{id:"basescript--candlesbuffer",children:"BaseScript + CandlesBuffer"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  private buffer: CandlesBuffer;\n\n  async onInit() {\n    // Get buffer through global service\n    this.buffer = await globals.candlesBufferService.getBuffer({\n      symbol: this.symbols[0],\n      timeframe: getArgString('timeframe', '1h'),\n      preloadCandlesCount: getArgNumber('candlesCount', 250)\n    });\n  }\n\n  async onTick() {\n    // Market data analysis\n    const trend = this.analyzeTrend();\n    const volatility = this.calculateVolatility();\n    \n    // Trading decisions based on analysis\n    if (trend === 'bullish' && volatility < 0.03) {\n      // Buy logic\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"ordersbasket--market-data",children:"OrdersBasket + Market Data"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  private basket: OrdersBasket;\n  private buffer: CandlesBuffer;\n\n  async onInit() {\n    this.basket = new OrdersBasket({\n      symbol: this.symbols[0],\n      connectionName: this.connectionName\n    });\n    await this.basket.init();\n    \n    // Get buffer through global service\n    this.buffer = await globals.candlesBufferService.getBuffer({\n      symbol: this.symbols[0],\n      timeframe: '1h'\n    });\n  }\n\n  async onTick() {\n    const currentPrice = this.basket.close();\n    const bufferPrice = this.buffer.close();\n    \n    // Compare data from different sources\n    if (Math.abs(currentPrice - bufferPrice) > currentPrice * 0.001) {\n      warning('PriceValidation', 'Price discrepancy between sources', { currentPrice, bufferPrice, difference: Math.abs(currentPrice - bufferPrice) });\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/jt-lib/trading-scripts",children:"Trading Scripts"})})," - Base class for trading scripts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/jt-lib/exchange-orders-basket",children:"Exchange Operations"})})," - OrdersBasket for trading operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/jt-lib/events-system",children:"Event System"})})," - EventEmitter for event management"]}),"\n"]})]})}function f(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var r=t(6540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);