"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[55],{850:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"jt-lib/events-system","title":"Event System (Events)","description":"The JT-LIB event system provides reactive programming and automation of trading strategies. It consists of EventEmitter for event management and a trigger system for automatic execution of actions based on conditions.","source":"@site/docs/jt-lib/events-system.md","sourceDirName":"jt-lib","slug":"/jt-lib/events-system","permalink":"/docs/docs/jt-lib/events-system","draft":false,"unlisted":false,"editUrl":"https://github.com/dev-zone-xs/jt-lab-docs/tree/main/git-docs-en/docs/docs/jt-lib/events-system.md","tags":[],"version":"current","frontMatter":{"id":"events-system","title":"Event System (Events)","sidebar_label":"Event System"},"sidebar":"tutorialSidebar","previous":{"title":"Error Handling","permalink":"/docs/docs/jt-lib/error-handling"},"next":{"title":"Trading Scripts","permalink":"/docs/docs/jt-lib/trading-scripts"}}');var r=t(4848),i=t(8453);const o={id:"events-system",title:"Event System (Events)",sidebar_label:"Event System"},c="Event System (Events)",a={},l=[{value:"EventEmitter - How the Event System Works",id:"eventemitter---how-the-event-system-works",level:2},{value:"Key Features",id:"key-features",level:3},{value:"Key Methods",id:"key-methods",level:3},{value:"subscribe()",id:"subscribe",level:4},{value:"subscribeOnTick()",id:"subscribeontick",level:4},{value:"subscribeOnOrderChange()",id:"subscribeonorderchange",level:4},{value:"emit()",id:"emit",level:4},{value:"Event Management System",id:"event-management-system",level:3},{value:"Event Subscription - How to Listen to System Changes",id:"event-subscription---how-to-listen-to-system-changes",level:2},{value:"Event Types",id:"event-types",level:3},{value:"System Events with Full Typing",id:"system-events-with-full-typing",level:4},{value:"Dynamic Symbol Events",id:"dynamic-symbol-events",level:4},{value:"Custom Events",id:"custom-events",level:4},{value:"Event Subscription Examples",id:"event-subscription-examples",level:3},{value:"Event Handler Examples",id:"event-handler-examples",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"event-system-events",children:"Event System (Events)"})}),"\n",(0,r.jsx)(n.p,{children:"The JT-LIB event system provides reactive programming and automation of trading strategies. It consists of EventEmitter for event management and a trigger system for automatic execution of actions based on conditions."}),"\n",(0,r.jsx)(n.h2,{id:"eventemitter---how-the-event-system-works",children:"EventEmitter - How the Event System Works"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"EventEmitter"})," is the central component of the event system, inheriting from ",(0,r.jsx)(n.code,{children:"BaseObject"}),". It manages event subscriptions, their execution, and automatic resource cleanup."]}),"\n",(0,r.jsx)(n.h3,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Event Subscription"})," - registration of handlers for various event types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic Lifecycle Management"})," - unsubscription when objects are destroyed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Specialized Events"})," - ",(0,r.jsx)(n.code,{children:"onTick"}),", ",(0,r.jsx)(n.code,{children:"onOrderChange"})," with symbol support"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handler Validation"})," - checking correctness of functions and owners"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Interval Management"})," - configuring tick execution frequency"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-methods",children:"Key Methods"}),"\n",(0,r.jsx)(n.h4,{id:"subscribe",children:"subscribe()"}),"\n",(0,r.jsx)(n.p,{children:"Main method for event subscription. Provides safe handler registration with full typing."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"New typing capabilities:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Generic typing"})," - ",(0,r.jsx)(n.code,{children:"subscribe<T extends EventName>(eventName: T, handler: TypedEventHandler<T>, owner: BaseObject)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic type inference"})," - TypeScript automatically determines data type for handler"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compile-time type checking"})," - preventing errors with incorrect data types"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Important limitations:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Doesn't support anonymous arrow functions (must be named function)"}),"\n",(0,r.jsxs)(n.li,{children:["Handler must be a method of class inheriting from ",(0,r.jsx)(n.code,{children:"BaseObject"})]}),"\n",(0,r.jsxs)(n.li,{children:["Owner must be an instance of ",(0,r.jsx)(n.code,{children:"BaseObject"})]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"subscribeontick",children:"subscribeOnTick()"}),"\n",(0,r.jsx)(n.p,{children:"Specialized method for tick subscription with configurable interval."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Subscribe to ticks with 30 second interval\nglobals.events.subscribeOnTick(this.onTick, this, 'BTC/USDT', 30*1000);\n\n// Subscribe with default interval (1000ms)\nglobals.events.subscribeOnTick(this.onTick, this, 'BTC/USDT');\n"})}),"\n",(0,r.jsx)(n.h4,{id:"subscribeonorderchange",children:"subscribeOnOrderChange()"}),"\n",(0,r.jsx)(n.p,{children:"Subscribe to order changes for specific symbol."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Subscribe to BTC/USDT order changes\nglobals.events.subscribeOnOrderChange(this.onOrderChange, this, 'BTC/USDT');\n"})}),"\n",(0,r.jsx)(n.h4,{id:"emit",children:"emit()"}),"\n",(0,r.jsx)(n.p,{children:"Event generation with full data typing."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"New capabilities:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Generic typing"})," - ",(0,r.jsx)(n.code,{children:"emit<T extends EventName>(eventName: T, data?: GetEventData<T>)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic type checking"})," - TypeScript checks data type compliance with event type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"IntelliSense support"})," - autocompletion for data types"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Typed event generation\nconst order: Order = { /* order data */ };\nawait globals.events.emit('onPnlChange', {\n  type: 'pnl',\n  amount: 100.50,\n  symbol: 'BTC/USDT',\n  order: order\n});\n\n// TypeScript will automatically check type compliance\n"})}),"\n",(0,r.jsx)(n.h3,{id:"event-management-system",children:"Event Management System"}),"\n",(0,r.jsx)(n.p,{children:"EventEmitter automatically manages event lifecycle:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatically unsubscribes objects from all events when destroyed"}),"\n",(0,r.jsx)(n.li,{children:"Prevents memory leaks through incorrect subscriptions"}),"\n",(0,r.jsx)(n.li,{children:"Ensures proper resource cleanup"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"event-subscription---how-to-listen-to-system-changes",children:"Event Subscription - How to Listen to System Changes"}),"\n",(0,r.jsx)(n.h3,{id:"event-types",children:"Event Types"}),"\n",(0,r.jsx)(n.h4,{id:"system-events-with-full-typing",children:"System Events with Full Typing"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"onTick"})})," - executed at specified interval (type: ",(0,r.jsx)(n.code,{children:"TickEventData"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"onOrderChange"})})," - order status changes (type: ",(0,r.jsx)(n.code,{children:"OrderChangeEventData"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"onPnlChange"})})," - profit/loss changes (type: ",(0,r.jsx)(n.code,{children:"PnlChangeEventData"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"onArgsUpdate"})})," - strategy argument updates (type: ",(0,r.jsx)(n.code,{children:"ArgsUpdateEventData"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"onTimer"})})," - timer events (type: ",(0,r.jsx)(n.code,{children:"TimerEventData"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"onTickEnded"})})," - tick completion (type: ",(0,r.jsx)(n.code,{children:"TickEndedEventData"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"onRun"})})," - strategy launch (type: ",(0,r.jsx)(n.code,{children:"RunEventData"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"onStop"})})," - strategy stop (type: ",(0,r.jsx)(n.code,{children:"StopEventData"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"onReportAction"})})," - report actions (type: ",(0,r.jsx)(n.code,{children:"ReportActionEventData"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"dynamic-symbol-events",children:"Dynamic Symbol Events"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"onTick_${symbol}"})})," - ticks for specific symbol"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"onOrderChange_${symbol}"})})," - order changes for specific symbol"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"custom-events",children:"Custom Events"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"emit()"})})," - custom event generation (type: ",(0,r.jsx)(n.code,{children:"CustomEventData"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"subscribe()"})})," - custom event subscription"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"event-subscription-examples",children:"Event Subscription Examples"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Subscribe to order changes for specific symbol\nglobals.events.subscribeOnOrderChange(this.handleOrderChange, this, 'BTC/USDT');\n\n// Subscribe to ticks for specific symbol with 5 second interval\nglobals.events.subscribeOnTick(this.processTick, this, 'BTC/USDT', 5000);\n\n// Subscribe to system events\nglobals.events.subscribe('onPnlChange', this.onPnlChange, this);\nglobals.events.subscribe('onArgsUpdate', this.onArgsUpdate, this);\nglobals.events.subscribe('onReportAction', this.onReportAction, this);\n\n// Subscribe to tester events\nglobals.events.subscribe('onAfterStop', this.onStopTester, this);\n\n// Subscribe to runtime events\nglobals.events.subscribe('onOrderChange', this.collectOrdersRuntime, this);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"event-handler-examples",children:"Event Handler Examples"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class MyService extends BaseObject {\n  constructor() {\n    super();\n    // Subscribe to events in constructor\n    globals.events.subscribe('onOrderChange', this.onOrderChange, this);\n    globals.events.subscribe('onTick', this.onTick, this);\n  }\n\n  // Order change handler\n  async onOrderChange(order: Order) {\n    log('OrderHandler', 'Order status changed', { orderId: order.id, status: order.status }, true);\n    if (order.status === 'closed') {\n      log('OrderHandler', 'Order filled', { orderId: order.id, filled: order.filled, amount: order.amount }, true);\n    }\n  }\n\n  // Tick handler\n  async onTick(data: Tick) {\n    trace('TickHandler', 'Price tick', { price: data.close, volume: data.volume }, true);\n  }\n\n  // PnL change handler\n  async onPnlChange(data: PnlChangeEventData) {\n    log('PnLHandler', 'PnL changed', { type: data.type, amount: data.amount, symbol: data.symbol }, true);\n  }\n}\n\n\n\n## Integration with Other Components\n\nThe event system in JT-LIB is integrated with the main library components. EventEmitter is created in the BaseScript constructor and then used throughout the system. The main event providers are BaseScript and OrdersBasket.\n\n### Event Providers\n\n#### BaseScript - Main Event Provider\n\n**BaseScript** generates the following events:\n- **`onTick`** - on each market data tick (via emitOnTick)\n- **`onTickEnded`** - tick completion\n- **`onTimer`** - timer events\n- **`onOrderChange`** - on order status change\n- **`onArgsUpdate`** - on strategy argument updates\n- **`onEvent`** - events from exchange websockets\n- **`onRun`** - strategy launch\n- **`onBeforeStop`** - before strategy stop\n- **`onStop`** - on strategy stop\n- **`onAfterStop`** - after strategy stop\n- **`onReportAction`** - report actions\n\n#### OrdersBasket - Trading Event Provider\n\n**OrdersBasket** generates the following events:\n- **`onPnlChange`** - on profit/loss changes (realized and unrealized)\n\n\n### Event Subscriptions\n\n#### TriggerService\nWhen created in constructor, subscribes to events:\n- **`onTick`** - for time-based task execution\n- **`onOrderChange`** - for order status-based task execution\n\n#### OrdersBasket\nWhen created in constructor, subscribes to events:\n- **`onOrderChange_${symbol}`** - for specific symbol\n- **`onTick_${symbol}`** - for specific symbol\n\n#### StandardReportLayout\nWhen created in constructor, subscribes to events:\n- **`onArgsUpdate`** - for argument update handling\n- **`onAfterStop`** - for tester stop handling\n- **`onOrderChange`** - for order change recording in runtime\n- **`onReportAction`** - for report action handling\n\n#### ReportStatistics\nWhen created in constructor, subscribes to events:\n- **`onOrderChange`** - for order statistics collection\n- **`onTick`** - for data collection\n\n#### ReportActionButton\nWhen created in constructor, subscribes to events:\n- **`onReportAction`** - for button action handling\n\n**Important:** BaseScript and all script examples do NOT subscribe to events directly. They only override event handling methods (`onTick`, `onOrderChange`, `onInit`, `onStop`, `onEvent`), which are called automatically by the system.\n\n### Automatic Lifecycle Management\n\nThe JT-LIB event system provides automatic subscription management to prevent memory leaks and incorrect handler calls.\n\n**Critical security issue:**\nIn JavaScript, when an object is destroyed, its methods (callback functions) remain in memory if there are references to them in EventEmitter. This leads to two serious problems:\n\n1. **Memory leaks** - objects are not freed from memory\n2. **Critical security threat** - callback functions may be called after object destruction, which is especially dangerous in trading systems where this can lead to unexpected trading operations\n\n**Especially critical in trading strategies:**\n- User may destroy an object, but callback functions continue to work\n- Strategy continues to work even after destroying the callback function owner object\n- This can lead to unpredictable financial losses\n- Therefore, it's critically important to check if the object is destroyed when calling callback functions\n\n**Solution through `owner` parameter:**\nWhen subscribing to events, an `owner` parameter is passed (usually `this`), which allows the system to track the state of the handler owner object.\n\n**BaseObject provides:**\n- Automatic unsubscription from all events when `destroy()` is called\n- Setting `_isDestroyed = true` flag when destroyed\n- Recursive destruction of child objects\n- Calling `unsubscribe()` to clean up all subscriptions\n\n**EventEmitter provides:**\n- **Checking `_isDestroyed` flag before calling handlers:**\n  ```typescript\n  if (listener.owner?._isDestroyed === true) {\n    error('EventEmitter::emit()', 'The owner of the listener is destroyed', {\n      ...listener,\n      owner: undefined,\n      data,\n    });\n    // Do NOT call listener.handler(data) - prevent trading operations!\n  } else {\n    let result = await listener.handler(data); // Safe call\n  }\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Automatic subscription removal via ",(0,r.jsx)(n.code,{children:"unsubscribeByObjectId()"})]}),"\n",(0,r.jsx)(n.li,{children:"Logging attempts to call methods of destroyed objects"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Critically important:"})," preventing trading operations by destroyed objects"]}),"\n",(0,r.jsx)(n.li,{children:"Error handling in event handlers"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Automatic cleanup example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class TradingService extends BaseObject {\n  constructor() {\n    super();\n    // Subscription with passing this as owner\n    globals.events.subscribe('onTick', this.onTick, this);\n  }\n  \n  async onTick(data: Tick) {\n    // DANGEROUS: without checking _isDestroyed, this method can\n    // execute even after object destruction!\n    await this.createOrder('buy', 100); // Trading operation!\n  }\n  \n  // When destroy() is called, automatically:\n  // 1. _isDestroyed = true is set\n  // 2. unsubscribe() is called\n  // 3. EventEmitter removes all subscriptions of this object\n  // 4. onTick will NO LONGER be called - trading operations stopped\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Without lifecycle management system:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// DANGEROUS CODE - DO NOT USE!\nclass DangerousService {\n  constructor() {\n    // Subscription WITHOUT owner - object is not tracked!\n    globals.events.subscribe('onTick', this.onTick, null);\n  }\n  \n  async onTick(data: Tick) {\n    // This method will be called even after object destruction!\n    await this.createOrder('buy', 100); // CRITICAL ERROR!\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This architecture ensures reliable memory management and prevents leaks when working with events in trading strategies."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);