"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[140],{1157:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"jt-lib/trading-scripts","title":"Trading Scripts (Script)","description":"Trading scripts are the foundation for creating trading strategies in jt-lib. They provide a structured approach to developing algorithmic trading systems with a clear lifecycle and market event handling.","source":"@site/docs/jt-lib/trading-scripts.md","sourceDirName":"jt-lib","slug":"/jt-lib/trading-scripts","permalink":"/docs/docs/jt-lib/trading-scripts","draft":false,"unlisted":false,"editUrl":"https://github.com/dev-zone-xs/jt-lab-docs/tree/main/git-docs-en/docs/docs/jt-lib/trading-scripts.md","tags":[],"version":"current","frontMatter":{"id":"trading-scripts","title":"Trading Scripts (Script)","sidebar_label":"Trading Scripts"},"sidebar":"tutorialSidebar","previous":{"title":"Event System","permalink":"/docs/docs/jt-lib/events-system"},"next":{"title":"Exchange Operations (OrdersBasket)","permalink":"/docs/docs/jt-lib/exchange-orders-basket"}}');var s=r(4848),i=r(8453);const a={id:"trading-scripts",title:"Trading Scripts (Script)",sidebar_label:"Trading Scripts"},o="Trading Scripts (Script)",l={},c=[{value:"Your First Trading Script - DCA Strategy",id:"your-first-trading-script---dca-strategy",level:2},{value:"DCA Strategy Workflow",id:"dca-strategy-workflow",level:3},{value:"BaseScript - Base Class for Trading Strategies",id:"basescript---base-class-for-trading-strategies",level:2},{value:"Main Properties",id:"main-properties",level:3},{value:"Global Services Initialization",id:"global-services-initialization",level:3},{value:"Script Lifecycle",id:"script-lifecycle",level:2},{value:"1. Constructor",id:"1-constructor",level:3},{value:"2. onInit()",id:"2-oninit",level:3},{value:"3. onTick()",id:"3-ontick",level:3},{value:"4. onOrderChange()",id:"4-onorderchange",level:3},{value:"5. onStop()",id:"5-onstop",level:3},{value:"Tick Processing - Market Data Retrieval",id:"tick-processing---market-data-retrieval",level:2},{value:"Important Limitation",id:"important-limitation",level:3},{value:"Working with Multiple Symbols",id:"working-with-multiple-symbols",level:3},{value:"Operation Modes",id:"operation-modes",level:3},{value:"Native Functions for Market Data Retrieval",id:"native-functions-for-market-data-retrieval",level:3},{value:"Script Parameters - Strategy Configuration",id:"script-parameters---strategy-configuration",level:2},{value:"Global ARGS Variable",id:"global-args-variable",level:3},{value:"GlobalARGS Type",id:"globalargs-type",level:3},{value:"Launch Modes",id:"launch-modes",level:3},{value:"Required Parameters",id:"required-parameters",level:3},{value:"User Parameters",id:"user-parameters",level:3},{value:"Advanced Strategy Examples",id:"advanced-strategy-examples",level:2},{value:"1. Multi-Symbol Strategy with OrdersBasket",id:"1-multi-symbol-strategy-with-ordersbasket",level:3},{value:"2. Timer-Based Strategy",id:"2-timer-based-strategy",level:3},{value:"3. Order-Based Strategy",id:"3-order-based-strategy",level:3},{value:"Additional Methods",id:"additional-methods",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Parameter Updates",id:"parameter-updates",level:3},{value:"Exchange Event Handling",id:"exchange-event-handling",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"trading-scripts-script",children:"Trading Scripts (Script)"})}),"\n",(0,s.jsxs)(n.p,{children:["Trading scripts are the foundation for creating trading strategies in ",(0,s.jsx)(n.code,{children:"jt-lib"}),". They provide a structured approach to developing algorithmic trading systems with a clear lifecycle and market event handling."]}),"\n",(0,s.jsx)(n.h2,{id:"your-first-trading-script---dca-strategy",children:"Your First Trading Script - DCA Strategy"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"DCA (Dollar Cost Averaging)"})," is a strategy of regular purchases for a fixed amount regardless of price. This reduces the impact of volatility and allows gradual asset accumulation."]}),"\n",(0,s.jsxs)(n.p,{children:["Here's a concise DCA strategy example using modern ",(0,s.jsx)(n.code,{children:"jt-lib"})," capabilities:"]}),"\n",(0,s.jsx)(n.h3,{id:"dca-strategy-workflow",children:"DCA Strategy Workflow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"DCA Script Launch\n    \u2193\nGet parameters: symbols, sizeUsd, intervalHours\n    \u2193\nInitialize global services (triggers, report, events)\n    \u2193\nonInit():\n    \u251c\u2500 Create StandardReportLayout\n    \u251c\u2500 Initialize OrdersBasket for symbol\n    \u251c\u2500 Register 'dcaPurchase' trigger\n    \u2514\u2500 Setup periodic purchases\n    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Main Operation Loop            \u2502\n\u2502                                         \u2502\n\u2502  Every intervalHours hours:            \u2502\n\u2502  \u251c\u2500 'dcaPurchase' trigger fires         \u2502\n\u2502  \u251c\u2500 buyDCA() is called                 \u2502\n\u2502  \u251c\u2500 Contract calculation: sizeUsd \u2192 amount \u2502\n\u2502  \u251c\u2500 Purchase execution: buyMarket()     \u2502\n\u2502  \u2514\u2500 Result logging                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2193\nonStop() - cancel all orders\n    \u2193\nWork completion\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  static definedArgs = [\n    { key: 'symbols', defaultValue: 'BTC/USDT:USDT' },\n    { key: 'sizeUsd', defaultValue: 100 },\n    { key: 'intervalHours', defaultValue: 168 },\n  ];\n\n  dcaBasket: OrdersBasket;\n  sizeUsd = getArgNumber('sizeUsd', 100);\n  intervalHours = getArgNumber('intervalHours', 168); // 168 hours = 1 week\n  private reportLayout: StandardReportLayout;\n\n  async onInit() {\n    // Initialize standard report\n    this.reportLayout = new StandardReportLayout();\n\n    // Create basket\n    this.dcaBasket = new OrdersBasket({\n      symbol: this.symbols[0],\n    });\n    await this.dcaBasket.init();\n\n    // Register purchase trigger\n    globals.triggers.registerTimeHandler('dcaPurchase', this.buyDCA, this);\n    \n    // Start regular purchases\n    globals.triggers.addTaskByTime({\n      name: 'dcaPurchase',\n      triggerTime: currentTime() + 60 * 1000, // In 1 minute\n      interval: this.intervalHours * 60 * 60 * 1000, // Repeat every intervalHours hours\n      canReStore: true,\n    });\n\n    globals.report.setTitle('DCA Bot');\n  }\n\n  // Purchase function\n  buyDCA = async () => {\n    const amount = this.dcaBasket.getContractsAmount(this.sizeUsd);\n    await this.dcaBasket.buyMarket(amount);\n    log('DCA purchase completed', `amount: ${amount}, price: ${this.dcaBasket.close()}`);\n  };\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key features of this example:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"static definedArgs"})})," - automatic parameter generation in JT-Trader"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modern triggers"})," - ",(0,s.jsx)(n.code,{children:"registerTimeHandler()"})," and ",(0,s.jsx)(n.code,{children:"addTaskByTime()"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic restoration"})," - ",(0,s.jsx)(n.code,{children:"canReStore: true"})," for restart after failures"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in reporting"})," - ",(0,s.jsx)(n.code,{children:"StandardReportLayout"})," for monitoring"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simplified initialization"})," - OrdersBasket without extra parameters"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Concise code"})," - minimum lines, maximum functionality"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"basescript---base-class-for-trading-strategies",children:"BaseScript - Base Class for Trading Strategies"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"BaseScript"})," is the fundamental class from which all trading strategies inherit. It provides:"]}),"\n",(0,s.jsx)(n.h3,{id:"main-properties",children:"Main Properties"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"connectionName"})})," - exchange connection name (required parameter)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"symbols"})})," - array of trading pairs for strategy operation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"interval"})})," - timer interval in milliseconds (if set, uses ",(0,s.jsx)(n.code,{children:"onTimer"})," instead of ",(0,s.jsx)(n.code,{children:"onTick"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"hedgeMode"})})," - position hedging mode"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"isInitialized"})})," - script initialization flag"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"balanceTotal"})})," and ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"balanceFree"})})," - total and free account balance"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"global-services-initialization",children:"Global Services Initialization"}),"\n",(0,s.jsxs)(n.p,{children:["When creating a ",(0,s.jsx)(n.code,{children:"BaseScript"})," instance, all global services are automatically initialized:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Automatically created in BaseScript constructor\nglobals.script = this;\nglobals.events = new EventEmitter();\nglobals.triggers = new TriggerService();\nglobals.report = new Report();\nglobals.storage = new Storage();\nglobals.candlesBufferService = new CandlesBufferService();\nglobals.indicators = new Indicators();\n\n// OrdersBasket is created manually for each symbol\n// import { OrdersBasket } from 'jt-lib';\n"})}),"\n",(0,s.jsx)(n.h2,{id:"script-lifecycle",children:"Script Lifecycle"}),"\n",(0,s.jsx)(n.h3,{id:"1-constructor",children:"1. Constructor"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"constructor(args: GlobalARGS) {\n  // Get parameters from ARGS\n  this.connectionName = getArgString('connectionName', undefined, true);\n  this.hedgeMode = getArgBoolean('hedgeMode', false);\n  \n  // Define symbols for trading\n  if (isTester()) {\n    this.symbols.push(args.symbol);\n  } else {\n    // Parse symbols from parameter string\n    let symbolsLine = getArgString('symbols', '');\n    // ... symbol processing\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-oninit",children:"2. onInit()"}),"\n",(0,s.jsx)(n.p,{children:"Called after instance creation and balance retrieval. Here happens:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Trading component initialization"}),"\n",(0,s.jsx)(n.li,{children:"Indicator setup"}),"\n",(0,s.jsx)(n.li,{children:"Initial order creation"}),"\n",(0,s.jsx)(n.li,{children:"Event subscription"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async onInit() {\n  // Initialize your strategy\n  log('Script', 'Strategy initialized', {}, true);\n  \n  // Get balance\n  log('Script', 'Total balance', { balanceTotal: this.balanceTotal }, true);\n  log('Script', 'Free balance', { balanceFree: this.balanceFree }, true);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-ontick",children:"3. onTick()"}),"\n",(0,s.jsxs)(n.p,{children:["Called on each new tick (price change) ",(0,s.jsx)(n.strong,{children:"only for the first symbol"})," in the ",(0,s.jsx)(n.code,{children:"symbols"})," list. When working with multiple symbols, use ",(0,s.jsx)(n.code,{children:"EventEmitter"})," to subscribe to ticks of specific symbols."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important:"})," The ",(0,s.jsx)(n.code,{children:"onTick()"})," method doesn't accept parameters. For market data retrieval, use native functions."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async onTick() {\n  // Get market data through native functions\n  const currentPrice = close(); // Close price of first symbol\n  const askPrice = ask()[0];    // Buy price from order book\n  const bidPrice = bid()[0];    // Sell price from order book\n  const volume = volume();      // Trading volume\n  \n  // Trading strategy logic\n  trace('Script', 'New tick', { currentPrice, volume, askPrice, bidPrice }, true);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-onorderchange",children:"4. onOrderChange()"}),"\n",(0,s.jsx)(n.p,{children:"Called when any order status changes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async onOrderChange(order: Order) {\n  log('OrderManager', 'Order status changed', { orderId: order.id, status: order.status }, true);\n  \n  if (order.status === 'filled') {\n    log('OrderManager', 'Order filled', { orderId: order.id, filled: order.filled, amount: order.amount }, true);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-onstop",children:"5. onStop()"}),"\n",(0,s.jsx)(n.p,{children:"Called when stopping the script for resource cleanup:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async onStop() {\n  log('Script', 'Strategy stopped', {}, true);\n  // Close positions, cancel orders, etc.\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"tick-processing---market-data-retrieval",children:"Tick Processing - Market Data Retrieval"}),"\n",(0,s.jsx)(n.h3,{id:"important-limitation",children:"Important Limitation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"onTick()"})," works only with the first symbol!"]})}),"\n",(0,s.jsxs)(n.p,{children:["When running a script on multiple symbols (",(0,s.jsx)(n.code,{children:"symbols: ['BTC/USDT', 'ETH/USDT', 'ADA/USDT']"}),"), the ",(0,s.jsx)(n.code,{children:"onTick()"})," method will be called ",(0,s.jsx)(n.strong,{children:"only for the first symbol"})," (",(0,s.jsx)(n.code,{children:"BTC/USDT"}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"working-with-multiple-symbols",children:"Working with Multiple Symbols"}),"\n",(0,s.jsxs)(n.p,{children:["To get ticks for all symbols, use ",(0,s.jsx)(n.code,{children:"EventEmitter"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async onInit() {\n  // Subscribe to ticks for each symbol\n  for (const symbol of this.symbols) {\n    globals.events.subscribeOnTick(() => this.onSymbolTick(symbol), this, symbol, 1000);\n  }\n}\n\nasync onSymbolTick(symbol: string) {\n  // Process tick for specific symbol\n  const currentPrice = close(symbol); // Use native function with symbol\n  trace('MultiSymbol', 'Tick for symbol', { symbol, currentPrice }, true);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"operation-modes",children:"Operation Modes"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tick mode"})," (default):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onTick()"})," is called on each new tick of ",(0,s.jsx)(n.strong,{children:"first symbol"})]}),"\n",(0,s.jsxs)(n.li,{children:["For other symbols, use ",(0,s.jsx)(n.code,{children:"EventEmitter"})]}),"\n",(0,s.jsxs)(n.li,{children:["Use native functions ",(0,s.jsx)(n.code,{children:"close()"}),", ",(0,s.jsx)(n.code,{children:"ask()"}),", ",(0,s.jsx)(n.code,{children:"bid()"})," for data retrieval"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Timer mode"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"interval"})," is set, uses ",(0,s.jsx)(n.code,{children:"onTimer()"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onTick()"})," is not called"]}),"\n",(0,s.jsx)(n.li,{children:"Useful for scheduled strategies"}),"\n",(0,s.jsxs)(n.li,{children:["In ",(0,s.jsx)(n.code,{children:"onTimer()"})," also use native functions for data retrieval"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  interval = 60000; // 1 minute - switch to timer mode\n  \n  async onTimer() {\n    // Called every minute\n    const currentPrice = close(); // Use native function\n    const askPrice = ask()[0];\n    const bidPrice = bid()[0];\n    \n    log('TimerStrategy', 'Timer triggered', { currentPrice, askPrice, bidPrice }, true);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"native-functions-for-market-data-retrieval",children:"Native Functions for Market Data Retrieval"}),"\n",(0,s.jsx)(n.p,{children:"For market data retrieval, use native functions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Main OHLC functions\nconst currentPrice = close();     // Close price (current price)\nconst openPrice = open();         // Open price\nconst highPrice = high();         // Maximum price\nconst lowPrice = low();           // Minimum price\nconst volume = volume();          // Trading volume\nconst timestamp = tms();          // Timestamp\n\n// Order book functions\nconst askData = ask();            // [price, volume] - buy price\nconst bidData = bid();            // [price, volume] - sell price\nconst askPrice = ask()[0];        // Only buy price\nconst bidPrice = bid()[0];        // Only sell price\n\n// For specific symbol (when working with multiple symbols)\nconst btcPrice = close('BTC/USDT');\nconst ethAsk = ask('ETH/USDT')[0];\n"})}),"\n",(0,s.jsx)(n.h2,{id:"script-parameters---strategy-configuration",children:"Script Parameters - Strategy Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"global-args-variable",children:"Global ARGS Variable"}),"\n",(0,s.jsxs)(n.p,{children:["When launching a script in JT-Trader, a global variable ",(0,s.jsx)(n.code,{children:"ARGS"})," is created, which contains all parameters passed at launch. This variable is accessible in all parts of the code through ",(0,s.jsx)(n.code,{children:"getArg*()"})," functions."]}),"\n",(0,s.jsx)(n.h3,{id:"globalargs-type",children:"GlobalARGS Type"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'type GlobalARGS = {\n  // Required parameters\n  connectionName: string;        // Exchange connection name\n  symbols: string;              // "BTC/USDT,ETH/USDT" - symbol list\n  symbol: string;               // "BTC/USDT" - first symbol\n  \n  // Tester parameters (only in testing mode)\n  start: string;                // "2021-01" - start date\n  end: string;                  // "2021-12" - end date\n  startDate: Date;              // "2021-01-01T00:00:00.000Z"\n  endDate: Date;                // "2021-12-31T23:59:59.999Z"\n  timeframe: string;            // Timeframe for testing\n  optimizerIteration: number;   // Optimizer iteration number\n  makerFee: number;             // Maker fee\n  takerFee: number;             // Taker fee\n  marketOrderSpread: number;    // Spread for market orders\n  balance: number;              // Initial balance\n  leverage: number;             // Leverage\n  \n  // User parameters\n} & Record<string, string | number | boolean>;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"launch-modes",children:"Launch Modes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. Runtime Mode (real-time trading)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Only required parameters and user parameters available"}),"\n",(0,s.jsx)(n.li,{children:"Tester parameters absent"}),"\n",(0,s.jsx)(n.li,{children:"Script works with real data"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Tester Mode (testing on historical data)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"All parameters available, including tester parameters"}),"\n",(0,s.jsx)(n.li,{children:"Script works with historical data"}),"\n",(0,s.jsx)(n.li,{children:"Parameter optimization supported"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"required-parameters",children:"Required Parameters"}),"\n",(0,s.jsx)(n.p,{children:"When creating a script in JT-Trader, you must specify:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"connectionName"})," - exchange connection name"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"symbols"})," - list of trading pairs (comma-separated)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"interval"})," - timeframe for strategy (optional)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"user-parameters",children:"User Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["Additional parameters are configured through JT-Trader interface and added to ",(0,s.jsx)(n.code,{children:"ARGS"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  private buyPrice: number;\n  private sellPrice: number;\n  private volume: number;\n  private isTestMode: boolean;\n  \n  async onInit() {\n    // Get user parameters\n    this.buyPrice = getArgNumber('buyPrice', 50000);\n    this.sellPrice = getArgNumber('sellPrice', 55000);\n    this.volume = getArgNumber('volume', 0.001);\n    this.isTestMode = getArgBoolean('isTestMode', false);\n    \n    // Check operation mode\n    if (getArgString('start')) {\n      log('Script', 'Launch in tester mode', { \n        start: getArgString('start'), \n        end: getArgString('end'),\n        balance: getArgNumber('balance')\n      }, true);\n    } else {\n      log('Script', 'Launch in Runtime mode', {}, true);\n    }\n    \n    log('Script', 'Strategy parameters', {\n      buyPrice: this.buyPrice,\n      sellPrice: this.sellPrice,\n      volume: this.volume,\n      isTestMode: this.isTestMode\n    }, true);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-strategy-examples",children:"Advanced Strategy Examples"}),"\n",(0,s.jsx)(n.h3,{id:"1-multi-symbol-strategy-with-ordersbasket",children:"1. Multi-Symbol Strategy with OrdersBasket"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Advantages of using OrdersBasket:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic contract management"})," \u2014 proper USD to contracts conversion for each symbol"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in SL/TP"})," \u2014 automatic stop-loss and take-profit order creation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Position management"})," \u2014 get information about current positions and their sizes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduce-only orders"})," \u2014 safe position closing without opening new ones"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Centralized management"})," \u2014 all orders for symbol managed through one object"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error handling"})," \u2014 built-in parameter validation and exchange error handling"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important:"})," OrdersBasket is created separately for each symbol, as each symbol has its own parameters (contract size, minimum volumes, fees)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  private baskets: Record<string, OrdersBasket> = {};\n  private positions: Record<string, number> = {};\n  private buyPrices: Record<string, number> = {};\n  private sellPrices: Record<string, number> = {};\n  private usdAmount: number = 100; // Position size in USD\n  \n  async onInit() {\n    log('MultiSymbolStrategy', 'Multi-symbol strategy with OrdersBasket launched', {}, true);\n    \n    // Setup prices for each symbol\n    this.buyPrices['BTC/USDT'] = 50000;\n    this.sellPrices['BTC/USDT'] = 55000;\n    this.buyPrices['ETH/USDT'] = 3000;\n    this.sellPrices['ETH/USDT'] = 3300;\n    \n    // Create OrdersBasket for each symbol\n    for (const symbol of this.symbols) {\n      this.baskets[symbol] = new OrdersBasket({\n        symbol: symbol,\n        connectionName: this.connectionName,\n        leverage: getArgNumber('leverage', 1),\n        hedgeMode: this.hedgeMode\n      });\n      \n      await this.baskets[symbol].init();\n      this.positions[symbol] = 0;\n      \n      // Subscribe to ticks for each symbol\n      globals.events.subscribeOnTick(() => this.onSymbolTick(symbol), this, symbol, 1000);\n      \n      log('MultiSymbolStrategy', 'OrdersBasket initialized', { symbol }, true);\n    }\n  }\n  \n  async onSymbolTick(symbol: string) {\n    const basket = this.baskets[symbol];\n    const currentPrice = close(symbol); // Use native function with symbol\n    const buyPrice = this.buyPrices[symbol];\n    const sellPrice = this.sellPrices[symbol];\n    \n    if (!basket || !buyPrice || !sellPrice) return;\n    \n    // Buy when target price reached\n    if (currentPrice <= buyPrice && this.positions[symbol] === 0) {\n      // Convert USD to contracts\n      const contracts = basket.getContractsAmount(this.usdAmount, currentPrice);\n      \n      // Create market order with automatic SL/TP\n      const slPrice = currentPrice * 0.95; // Stop Loss 5% below\n      const tpPrice = currentPrice * 1.05; // Take Profit 5% above\n      \n      const order = await basket.buyMarket(contracts, tpPrice, slPrice);\n      this.positions[symbol] = 1;\n      \n      log('MultiSymbolStrategy', 'Bought contracts', { \n        symbol, contracts, currentPrice, slPrice, tpPrice, orderId: order.id \n      }, true);\n    }\n    \n    // Sell when target price reached\n    if (currentPrice >= sellPrice && this.positions[symbol] === 1) {\n      // Get current position\n      const position = await basket.getPosition();\n      if (position && position.size > 0) {\n        // Close position through reduce-only order\n        const closeOrder = await basket.createReduceOrder(\n          'market',\n          'long', // close long position\n          Math.abs(position.size), // position size\n          currentPrice\n        );\n        \n        this.positions[symbol] = 0;\n        log('MultiSymbolStrategy', 'Closed position', { \n          symbol, currentPrice, closeOrderId: closeOrder.id \n        }, true);\n      }\n    }\n  }\n  \n  async onStop() {\n    // Close all positions when stopping\n    for (const symbol of this.symbols) {\n      const basket = this.baskets[symbol];\n      if (basket) {\n        await basket.cancelAllOrders();\n        log('MultiSymbolStrategy', 'All orders cancelled', { symbol }, true);\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-timer-based-strategy",children:"2. Timer-Based Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  interval = 300000; // 5 minutes\n  private basket: OrdersBasket;\n  private lastAction: number = 0;\n  private usdAmount: number = 100;\n  \n  async onInit() {\n    log('TimerStrategy', 'Timer-based strategy launched', {}, true);\n    \n    // Create OrdersBasket for first symbol\n    this.basket = new OrdersBasket({\n      symbol: this.symbols[0],\n      connectionName: this.connectionName,\n      leverage: getArgNumber('leverage', 1),\n      hedgeMode: this.hedgeMode\n    });\n    \n    await this.basket.init();\n  }\n  \n  async onTimer() {\n    const now = Date.now();\n    \n    // Action every 5 minutes\n    if (now - this.lastAction > 300000) {\n      log('TimerStrategy', 'Execute timer action', {}, true);\n      \n      // Get market data through native functions\n      const currentPrice = close();\n      const askPrice = ask()[0];\n      const bidPrice = bid()[0];\n      \n      trace('TimerStrategy', 'Market data', { currentPrice, askPrice, bidPrice }, true);\n      \n      // Strategy logic\n      const balance = await getBalance();\n      log('TimerStrategy', 'Current balance', { balance: balance.total.USDT }, true);\n      \n      // Example timer-based trading\n      const contracts = this.basket.getContractsAmount(this.usdAmount, currentPrice);\n      log('TimerStrategy', 'Contract calculation', { contracts, usdAmount: this.usdAmount }, true);\n      \n      this.lastAction = now;\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-order-based-strategy",children:"3. Order-Based Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  private basket: OrdersBasket;\n  private pendingOrders: string[] = [];\n  private usdAmount: number = 100;\n  \n  async onInit() {\n    log('OrderBasedStrategy', 'Order-based strategy launched', {}, true);\n    \n    // Create OrdersBasket for first symbol\n    this.basket = new OrdersBasket({\n      symbol: this.symbols[0],\n      connectionName: this.connectionName,\n      leverage: getArgNumber('leverage', 1),\n      hedgeMode: this.hedgeMode\n    });\n    \n    await this.basket.init();\n    \n    // Create initial order\n    const currentPrice = close();\n    const contracts = this.basket.getContractsAmount(this.usdAmount, currentPrice);\n    const limitPrice = currentPrice * 0.9; // 10% below current price\n    \n    const order = await this.basket.buyLimit(contracts, limitPrice);\n    this.pendingOrders.push(order.id);\n    log('OrderBasedStrategy', 'Created buy limit order', { contracts, limitPrice, orderId: order.id }, true);\n  }\n  \n  async onOrderChange(order: Order) {\n    log('OrderBasedStrategy', 'Order status changed', { orderId: order.id, status: order.status }, true);\n    \n    if (order.status === 'filled') {\n      // Order filled\n      this.pendingOrders = this.pendingOrders.filter(id => id !== order.id);\n      \n      if (order.side === 'buy') {\n        // After purchase, create sell order\n        const currentPrice = close();\n        const contracts = this.basket.getContractsAmount(this.usdAmount, currentPrice);\n        const sellPrice = order.price * 1.02; // 2% above purchase price\n        \n        const sellOrder = await this.basket.sellLimit(contracts, sellPrice);\n        this.pendingOrders.push(sellOrder.id);\n        log('OrderBasedStrategy', 'Created sell limit order', { contracts, sellPrice, orderId: sellOrder.id }, true);\n      }\n    }\n    \n    if (order.status === 'cancelled') {\n      // Order cancelled\n      this.pendingOrders = this.pendingOrders.filter(id => id !== order.id);\n      log('OrderBasedStrategy', 'Order cancelled', { orderId: order.id }, true);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"additional-methods",children:"Additional Methods"}),"\n",(0,s.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"onError = async (e: any): Promise<never | void> => {\n  console.error('Strategy error:', e);\n  // Custom error handling\n  throw e;\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"parameter-updates",children:"Parameter Updates"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async onArgsUpdate(args: GlobalARGS) {\n  log('Script', 'Strategy parameters updated', { args }, true);\n  // Update logic when parameters change\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"exchange-event-handling",children:"Exchange Event Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async onEvent(event: string, data: any) {\n  log('ExchangeEvents', 'Exchange event', { event, data }, true);\n  // Handle WebSocket events\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Use ",(0,s.jsx)(n.code,{children:"onInit()"})," for initialization"]})," - don't perform heavy operations in constructor"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use OrdersBasket for trading"})," - don't use direct trading methods, always work through OrdersBasket"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use native functions for data"})," - ",(0,s.jsx)(n.code,{children:"close()"}),", ",(0,s.jsx)(n.code,{children:"ask()"}),", ",(0,s.jsx)(n.code,{children:"bid()"})," instead of parameters in ",(0,s.jsx)(n.code,{children:"onTick()"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Properly convert volumes"})," - use ",(0,s.jsx)(n.code,{children:"getContractsAmount()"})," to convert USD to contracts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle errors"})," - override ",(0,s.jsx)(n.code,{children:"onError()"})," for custom error handling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Manage resources"})," - use ",(0,s.jsx)(n.code,{children:"onStop()"})," for cleanup and order cancellation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Check initialization"})," - use ",(0,s.jsx)(n.code,{children:"isInitialized"})," flag"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Log actions"})," - use ",(0,s.jsx)(n.code,{children:"log()"}),", ",(0,s.jsx)(n.code,{children:"warning()"}),", ",(0,s.jsx)(n.code,{children:"error()"})," functions"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/jt-lib/events-system",children:"Event System"})})," - In-depth study of EventEmitter"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/jt-lib/core-fundamentals",children:"Core Fundamentals"})})," - Basic system components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/jt-lib/introduction-architecture",children:"Introduction and Architecture"})})," - Library overview"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(6540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);