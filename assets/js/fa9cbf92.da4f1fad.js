"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[185],{1896:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"jt-trader/global-native-functions","title":"JT-Trader System Native Functions","description":"This documentation describes the native functions available in the global scope when developing trading strategies in JT-Trader. These functions provide direct access to trading operations, market data, and system capabilities of the platform.","source":"@site/docs/jt-trader/global-native-functions.md","sourceDirName":"jt-trader","slug":"/jt-trader/global-native-functions","permalink":"/docs/docs/jt-trader/global-native-functions","draft":false,"unlisted":false,"editUrl":"https://github.com/dev-zone-xs/jt-lab-docs/tree/main/git-docs-en/docs/docs/jt-trader/global-native-functions.md","tags":[],"version":"current","frontMatter":{"id":"global-native-functions","title":"JT-Trader System Native Functions","sidebar_label":"Native Functions"},"sidebar":"tutorialSidebar","previous":{"title":"Configuration","permalink":"/docs/docs/jt-trader/configuration"}}');var i=r(4848),t=r(8453);const c={id:"global-native-functions",title:"JT-Trader System Native Functions",sidebar_label:"Native Functions"},l="JT-Trader System Native Functions",a={},o=[{value:"Function Architecture",id:"function-architecture",level:2},{value:"Runtime Environment Functions",id:"runtime-environment-functions",level:2},{value:"getArtifactsKey()",id:"getartifactskey",level:3},{value:"registerCallback()",id:"registercallback",level:3},{value:"isTester()",id:"istester",level:3},{value:"updateReport()",id:"updatereport",level:3},{value:"getCache() / setCache()",id:"getcache--setcache",level:3},{value:"getPrefix()",id:"getprefix",level:3},{value:"setLeverage()",id:"setleverage",level:3},{value:"Market Data Functions",id:"market-data-functions",level:2},{value:"symbolInfo()",id:"symbolinfo",level:3},{value:"OHLC Data Functions",id:"ohlc-data-functions",level:3},{value:"ask() / bid()",id:"ask--bid",level:3},{value:"getHistory()",id:"gethistory",level:3},{value:"Trading Functions",id:"trading-functions",level:2},{value:"getPositions()",id:"getpositions",level:3},{value:"getBalance()",id:"getbalance",level:3},{value:"Order Management Functions",id:"order-management-functions",level:3},{value:"getOrders() / getOpenOrders() / getClosedOrders()",id:"getorders--getopenorders--getclosedorders",level:4},{value:"getOrder()",id:"getorder",level:4},{value:"createOrder()",id:"createorder",level:3},{value:"cancelOrder()",id:"cancelorder",level:3},{value:"modifyOrder()",id:"modifyorder",level:3},{value:"Testing Functions",id:"testing-functions",level:2},{value:"getFee()",id:"getfee",level:3},{value:"getProfit()",id:"getprofit",level:3},{value:"System Functions",id:"system-functions",level:2},{value:"SDK Functions",id:"sdk-functions",level:3},{value:"forceStop()",id:"forcestop",level:3},{value:"systemUsage()",id:"systemusage",level:3},{value:"getErrorTrace()",id:"geterrortrace",level:3},{value:"getUserId()",id:"getuserid",level:3},{value:"Global Objects",id:"global-objects",level:2},{value:"ARGS",id:"args",level:3},{value:"axios",id:"axios",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"jt-trader-system-native-functions",children:"JT-Trader System Native Functions"})}),"\n",(0,i.jsx)(n.p,{children:"This documentation describes the native functions available in the global scope when developing trading strategies in JT-Trader. These functions provide direct access to trading operations, market data, and system capabilities of the platform."}),"\n",(0,i.jsx)(n.h2,{id:"function-architecture",children:"Function Architecture"}),"\n",(0,i.jsx)(n.p,{children:"JT-Trader native functions are closely related to the CCXT (CryptoCurrency eXchange Trading) library. Some functions are direct calls to CCXT methods, while others have been rewritten and adapted to ensure interface unification."}),"\n",(0,i.jsx)(n.p,{children:"This architecture was implemented so that functionality works the same way in both the tester and runtime, ensuring consistent behavior of trading operations regardless of execution mode."}),"\n",(0,i.jsx)(n.h2,{id:"runtime-environment-functions",children:"Runtime Environment Functions"}),"\n",(0,i.jsx)(n.h3,{id:"getartifactskey",children:"getArtifactsKey()"}),"\n",(0,i.jsx)(n.p,{children:"Returns a unique artifact key for the current script, used for storing report data."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function getArtifactsKey(): string;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'let artifactsKey = getArtifactsKey();\nlet reportUrl = "https://env1.jtnodes.one/report/" + artifactsKey;\n'})}),"\n",(0,i.jsx)(n.h3,{id:"registercallback",children:"registerCallback()"}),"\n",(0,i.jsx)(n.p,{children:"Registers a callback function for trading operations (development mode only)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function registerCallback(funcName: string, callback: (...args: any[]) => void): void;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"funcName"})," - function name (createOrder, cancelOrder, modifyOrder, getOrders, getPositions, getBalance)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"callback"})," - callback function (asynchronous only)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"istester",children:"isTester()"}),"\n",(0,i.jsx)(n.p,{children:"Determines if the script is running in testing mode."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function isTester(): boolean;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"if (isTester()) {\n  // Logic only for tester\n  log('Script', 'Running in testing mode', {}, true);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"updatereport",children:"updateReport()"}),"\n",(0,i.jsx)(n.p,{children:"Updates the report for the current script. Maximum update frequency - once per second. Maximum report size - 1MB."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function updateReport(data: ReportData): Promise<void>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Important:"})," Avoid calling in loops without execution interval control (especially in onTick, onTimer)."]}),"\n",(0,i.jsx)(n.h3,{id:"getcache--setcache",children:"getCache() / setCache()"}),"\n",(0,i.jsx)(n.p,{children:"Functions for working with data cache."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function setCache(key: string, value: any): Promise<void>;\nfunction getCache<T>(key: string): Promise<T>;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getprefix",children:"getPrefix()"}),"\n",(0,i.jsx)(n.p,{children:"Returns the prefix of the current script scenario. Used for generating clientOrderId."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function getPrefix(): string;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"clientOrderId generation logic:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If user provided clientOrderId: ",(0,i.jsx)(n.code,{children:"{prefix}.{userClientOrderId}"})]}),"\n",(0,i.jsxs)(n.li,{children:["If not provided: ",(0,i.jsx)(n.code,{children:"{prefix}.{hashOfTimestamp}"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"setleverage",children:"setLeverage()"}),"\n",(0,i.jsx)(n.p,{children:"Sets leverage for futures trading."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function setLeverage(leverage: number, symbol: string): Promise<any>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"CCXT function:"})," ",(0,i.jsx)(n.code,{children:"setLeverage(leverage, symbol)"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"leverage"})," - leverage value (1-125)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"symbol"})," - symbol name (spot: BTC/USDT or futures: BTC/USDT",":USDT",")"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"market-data-functions",children:"Market Data Functions"}),"\n",(0,i.jsx)(n.h3,{id:"symbolinfo",children:"symbolInfo()"}),"\n",(0,i.jsx)(n.p,{children:"Returns information about a trading symbol."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function symbolInfo(symbol: string): Promise<SymbolInfo>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"CCXT source:"})," ",(0,i.jsx)(n.code,{children:"ccxt.markets[symbol]"})]}),"\n",(0,i.jsx)(n.h3,{id:"ohlc-data-functions",children:"OHLC Data Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function tms(symbol?: string): number;    // Current candle timestamp\nfunction open(symbol?: string): number;   // Open price\nfunction high(symbol?: string): number;   // Maximum price\nfunction low(symbol?: string): number;    // Minimum price\nfunction close(symbol?: string): number;  // Close price\nfunction volume(symbol?: string): number; // Trading volume\n"})}),"\n",(0,i.jsx)(n.h3,{id:"ask--bid",children:"ask() / bid()"}),"\n",(0,i.jsx)(n.p,{children:"Return buy and sell prices from the order book."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function ask(symbol?: string, index: number = 0): [number, number];\nfunction bid(symbol?: string, index: number = 0): [number, number];\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return value:"})," ",(0,i.jsx)(n.code,{children:"[price, volume]"})]}),"\n",(0,i.jsx)(n.h3,{id:"gethistory",children:"getHistory()"}),"\n",(0,i.jsx)(n.p,{children:"Gets historical candle data."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function getHistory(symbol: string, timeframe: TimeFrame, startTime: number, limit?: number): Promise<OHLC[]>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"CCXT function:"})," ",(0,i.jsx)(n.code,{children:"fetchOHLCV(symbol, timeframe, since, limit)"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"symbol"})," - symbol name"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"timeframe"})," - candle timeframe ('1m', '5m', '15m', '1h', '1d')"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"startTime"})," - start time (timestamp)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"limit"})," - number of candles"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"let candles = await getHistory('BTC/USDT', '1h', 1614556800000, 10);\n// Result: [timestamp, open, high, low, close, volume]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"trading-functions",children:"Trading Functions"}),"\n",(0,i.jsx)(n.h3,{id:"getpositions",children:"getPositions()"}),"\n",(0,i.jsx)(n.p,{children:"Returns an array of open positions."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function getPositions(symbols?: string[], options = {}): Promise<Position[]>;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"CCXT function:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"By default: system subscribes to events and positions are returned from WebSocket connections"}),"\n",(0,i.jsxs)(n.li,{children:["With ",(0,i.jsx)(n.code,{children:"isForce = true"}),": ",(0,i.jsx)(n.code,{children:"fetchPositions(symbols, params)"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"let positions = await getPositions();\nfor (let position of positions) {\n  log('PositionManager', 'Position info', { \n    symbol: position.symbol, \n    size: position.contracts, \n    entryPrice: position.entryPrice \n  }, true);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getbalance",children:"getBalance()"}),"\n",(0,i.jsx)(n.p,{children:"Returns account balance information."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function getBalance(): Promise<{\n  total: { USDT: number; [coin: string]: number };\n  used: { USDT: number; [coin: string]: number };\n  free: { USDT: number; [coin: string]: number };\n}>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"CCXT function:"})," ",(0,i.jsx)(n.code,{children:"fetchBalance()"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"let balance = await getBalance();\nlog('BalanceManager', 'Free balance', { balance: balance.free.USDT }, true);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"order-management-functions",children:"Order Management Functions"}),"\n",(0,i.jsx)(n.h4,{id:"getorders--getopenorders--getclosedorders",children:"getOrders() / getOpenOrders() / getClosedOrders()"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function getOrders(symbol: string, since = 0, limit = 500, params: any = undefined): Promise<Order[]>;\nfunction getOpenOrders(symbol: string, since = 0, limit = 500, params: any = undefined): Promise<Order[]>;\nfunction getClosedOrders(symbol: string, since = 0, limit = 500, params: any = undefined): Promise<Order[]>;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"CCXT functions:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"getOrders()"})," - may combine multiple CCXT methods depending on exchange (e.g., ",(0,i.jsx)(n.code,{children:"fetchOrders()"}),", ",(0,i.jsx)(n.code,{children:"fetchOpenOrders()"}),", ",(0,i.jsx)(n.code,{children:"fetchClosedOrders()"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"getOpenOrders()"})," - may contain multiple CCXT functions, as some exchanges separate trigger orders and regular open orders"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"getClosedOrders()"})," - similarly may combine multiple CCXT methods to get all types of closed orders"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"getorder",children:"getOrder()"}),"\n",(0,i.jsx)(n.p,{children:"Gets an order by ID."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function getOrder(id: string, symbol = ''): Promise<Order>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"CCXT function:"})," ",(0,i.jsx)(n.code,{children:"fetchOrder(id, symbol)"})]}),"\n",(0,i.jsx)(n.h3,{id:"createorder",children:"createOrder()"}),"\n",(0,i.jsx)(n.p,{children:"Creates a new order."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function createOrder(\n  symbol: string,\n  type: OrderType,\n  side: OrderSide,\n  amount: number,\n  price: number,\n  params: Record<string, unknown>\n): Promise<Order>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"CCXT function:"})," ",(0,i.jsx)(n.code,{children:"createOrder(symbol, type, side, amount, price, params)"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"symbol"})," - trading symbol"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"type"})," - order type ('limit', 'market')"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"side"})," - direction ('buy', 'sell')"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"amount"})," - quantity in base currency"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"price"})," - price (for limit orders)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"params"})," - additional parameters"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage Examples:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Market order\nlet order = await createOrder('BTC/USDT', 'market', 'buy', 0.01, 10000, {});\n\n// Stop-loss order\nlet sl = await createOrder('BTC/USDT', 'market', 'sell', 0.01, 9000, {\n  stopLossPrice: 9000, \n  reduceOnly: true\n});\n\n// Take-profit order\nlet tp = await createOrder('BTC/USDT', 'market', 'sell', 0.01, 11000, {\n  takeProfitPrice: 11000, \n  reduceOnly: true\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"cancelorder",children:"cancelOrder()"}),"\n",(0,i.jsx)(n.p,{children:"Cancels an order."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function cancelOrder(id: string, symbol: string): Promise<Order>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"CCXT function:"})," ",(0,i.jsx)(n.code,{children:"cancelOrder(id, symbol)"})]}),"\n",(0,i.jsx)(n.h3,{id:"modifyorder",children:"modifyOrder()"}),"\n",(0,i.jsx)(n.p,{children:"Modifies an existing order."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function modifyOrder(\n  id: string,\n  symbol: string,\n  type: OrderType,\n  side: OrderSide,\n  amount: number,\n  price: number,\n  params = {}\n): Promise<Order>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"CCXT function:"})," ",(0,i.jsx)(n.code,{children:"editOrder(id, symbol, type, side, amount, price, params)"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"let order = await modifyOrder('5203624294025367390', 'BTC/USDT:USDT', 'limit', 'buy', 0.01, 10000);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-functions",children:"Testing Functions"}),"\n",(0,i.jsx)(n.h3,{id:"getfee",children:"getFee()"}),"\n",(0,i.jsx)(n.p,{children:"Returns total commission for all executed orders (tester only)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function getFee(): number;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getprofit",children:"getProfit()"}),"\n",(0,i.jsx)(n.p,{children:"Returns profit/loss for all closed positions (tester only)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function getProfit(): Promise<number>;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"system-functions",children:"System Functions"}),"\n",(0,i.jsx)(n.h3,{id:"sdk-functions",children:"SDK Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"async function sdkCall(method: string, args: any[]): Promise<any>;\nasync function sdkGetProp(property: string): Promise<any>;\nasync function sdkSetProp(property: string, value: any): Promise<void>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," These functions allow calling any CCXT methods and working with their properties that were not exposed to the global context. This way, you can access the full functionality of the CCXT library, even if specific methods are not represented as separate native functions."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Usage Examples:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Call any CCXT method\nlet result = await sdkCall('fetchTradingFees', ['BTC/USDT']);\n\n// Get CCXT object property\nlet markets = await sdkGetProp('markets');\n\n// Set CCXT object property\nawait sdkSetProp('sandbox', true);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"forcestop",children:"forceStop()"}),"\n",(0,i.jsx)(n.p,{children:"Forcibly stops script execution."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function forceStop(): void;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"systemusage",children:"systemUsage()"}),"\n",(0,i.jsx)(n.p,{children:"Returns system resource usage information."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function systemUsage(): { cpu: number; memory: number };\n"})}),"\n",(0,i.jsx)(n.h3,{id:"geterrortrace",children:"getErrorTrace()"}),"\n",(0,i.jsx)(n.p,{children:"Gets error trace."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function getErrorTrace(stack: string): Promise<string>;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getuserid",children:"getUserId()"}),"\n",(0,i.jsx)(n.p,{children:"Returns user ID."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const getUserId: () => string;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"global-objects",children:"Global Objects"}),"\n",(0,i.jsx)(n.h3,{id:"args",children:"ARGS"}),"\n",(0,i.jsx)(n.p,{children:"Global constant containing script arguments."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const ARGS: GlobalARGS;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"axios",children:"axios"}),"\n",(0,i.jsx)(n.p,{children:"Global HTTP client instance for external requests."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const axios: any;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"JT-Trader native functions provide a powerful and unified interface for developing trading strategies. They abstract the complexity of working with various exchanges and provide a consistent API for all trading operations, market data work, and system functions."}),"\n",(0,i.jsx)(n.p,{children:"When developing strategies, it's important to consider the features of each function, properly handle errors, and use appropriate checks for different execution modes (testing vs real trading)."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>l});var s=r(6540);const i={},t=s.createContext(i);function c(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);