"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[989],{635:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"jt-lib/triggers-system","title":"Triggers System","description":"TriggerService manages the triggers system, which automatically executes actions when certain conditions are met. Triggers are integrated with the storage system and can be restored after strategy restart.","source":"@site/docs/jt-lib/triggers-system.md","sourceDirName":"jt-lib","slug":"/jt-lib/triggers-system","permalink":"/docs/docs/jt-lib/triggers-system","draft":false,"unlisted":false,"editUrl":"https://github.com/dev-zone-xs/jt-lab-docs/tree/main/git-docs-en/docs/docs/jt-lib/triggers-system.md","tags":[],"version":"current","frontMatter":{"id":"triggers-system","title":"Triggers System","sidebar_label":"Triggers System"},"sidebar":"tutorialSidebar","previous":{"title":"Exchange Operations (OrdersBasket)","permalink":"/docs/docs/jt-lib/exchange-orders-basket"},"next":{"title":"Market Data","permalink":"/docs/docs/jt-lib/market-data-candles"}}');var i=n(4848),s=n(8453);const a={id:"triggers-system",title:"Triggers System",sidebar_label:"Triggers System"},c="Triggers System",o={},l=[{value:"\u26a0\ufe0f Important: Ways to Register Callbacks",id:"\ufe0f-important-ways-to-register-callbacks",level:2},{value:"1. Direct Callback Passing (Arrow Function)",id:"1-direct-callback-passing-arrow-function",level:3},{value:"2. Callback Registration by Name (Regular Function)",id:"2-callback-registration-by-name-regular-function",level:3},{value:"\ud83d\udd04 Trigger Restoration on Reload",id:"-trigger-restoration-on-reload",level:3},{value:"Trigger Architecture",id:"trigger-architecture",level:2},{value:"Trigger Types",id:"trigger-types",level:2},{value:"Order Triggers",id:"order-triggers",level:3},{value:"Price Triggers",id:"price-triggers",level:3},{value:"Time Triggers",id:"time-triggers",level:3},{value:"Trigger Storage System",id:"trigger-storage-system",level:2},{value:"Trigger Management",id:"trigger-management",level:2},{value:"Handler Registration",id:"handler-registration",level:3},{value:"Task Creation",id:"task-creation",level:3},{value:"Task Cancellation",id:"task-cancellation",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Automatic Stop Loss and Take Profit Management",id:"automatic-stop-loss-and-take-profit-management",level:3},{value:"Price Triggers for Position Entry",id:"price-triggers-for-position-entry",level:3},{value:"Time Triggers for Reports",id:"time-triggers-for-reports",level:3},{value:"Integration with Other Components",id:"integration-with-other-components",level:2},{value:"TriggerService + EventEmitter",id:"triggerservice--eventemitter",level:3},{value:"Storage + Triggers",id:"storage--triggers",level:3},{value:"BaseScript + Triggers",id:"basescript--triggers",level:3},{value:"Next Steps",id:"next-steps",level:2}];function g(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"triggers-system",children:"Triggers System"})}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"TriggerService"})," manages the triggers system, which automatically executes actions when certain conditions are met. Triggers are integrated with the storage system and can be restored after strategy restart."]}),"\n",(0,i.jsx)(r.h2,{id:"\ufe0f-important-ways-to-register-callbacks",children:"\u26a0\ufe0f Important: Ways to Register Callbacks"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"There are two ways to pass an executable function to a trigger:"})}),"\n",(0,i.jsx)(r.h3,{id:"1-direct-callback-passing-arrow-function",children:"1. Direct Callback Passing (Arrow Function)"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-typescript",children:"// \u2705 Correct - arrow function\ntrigger.addTask({\n  name: 'myTask',\n  triggerPrice: 50000,\n  callback: async (args) => {\n    log('PriceTrigger', 'Trigger activated!', { args }, true);\n  }\n});\n"})}),"\n",(0,i.jsx)(r.h3,{id:"2-callback-registration-by-name-regular-function",children:"2. Callback Registration by Name (Regular Function)"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-typescript",children:"// \u2705 Correct - regular function registration\nclass Script extends BaseScript {\n  async onInit() {\n    // Register function by name\n    this.triggerService.registerHandler('myTask', this.onPriceTrigger, this);\n    \n    // Add task without callback\n    trigger.addTask({\n      name: 'myTask',\n      triggerPrice: 50000,\n      canReStore: true // \u26a0\ufe0f IMPORTANT: only for registered functions!\n    });\n  }\n  \n  // Regular function (not arrow!)\n  async onPriceTrigger(args: any) {\n    log('PriceTrigger', 'Trigger activated!', { args }, true);\n  }\n}\n\n// \u274c INCORRECT - arrow functions cannot be registered\nclass Script extends BaseScript {\n  async onInit() {\n    // \u274c Error! Arrow functions are not supported for registration\n    this.triggerService.registerHandler('myTask', (args) => {\n      log('PriceTrigger', 'This won\\'t work!', { args }, true);\n    }, this);\n  }\n}\n"})}),"\n",(0,i.jsx)(r.h3,{id:"-trigger-restoration-on-reload",children:"\ud83d\udd04 Trigger Restoration on Reload"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Key Difference:"})," Only registered callbacks can be restored when the script is reloaded!"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\u2705 ",(0,i.jsx)(r.strong,{children:"Registered functions"})," (",(0,i.jsx)(r.code,{children:"canReStore: true"}),") \u2014 restored automatically"]}),"\n",(0,i.jsxs)(r.li,{children:["\u274c ",(0,i.jsx)(r.strong,{children:"Arrow functions"})," \u2014 NOT restored on reload"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"trigger-architecture",children:"Trigger Architecture"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Centralized Management"})," - all triggers are managed through ",(0,i.jsx)(r.code,{children:"TriggerService"})]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Automatic Storage"})," - trigger state is saved in Storage"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Restoration After Restart"})," - triggers automatically restore their state"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Event Integration"})," - triggers subscribe to appropriate events"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"trigger-types",children:"Trigger Types"}),"\n",(0,i.jsx)(r.h3,{id:"order-triggers",children:"Order Triggers"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"OrderTrigger"})," executes actions when order status changes."]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Key Features:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"React to order status changes (open, filled, canceled)"}),"\n",(0,i.jsxs)(r.li,{children:["Support for both ",(0,i.jsx)(r.code,{children:"orderId"})," and ",(0,i.jsx)(r.code,{children:"clientOrderId"})]}),"\n",(0,i.jsx)(r.li,{children:"Automatic task lifecycle management"}),"\n",(0,i.jsx)(r.li,{children:"Storage system integration"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Usage Examples:"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-typescript",children:"// Register handler\nglobals.triggers.registerOrderHandler('createSlTp', this.createSlTp, this);\n\n// Create task\nglobals.triggers.addTaskByOrder({\n  name: 'createSlTp',\n  orderId: '12345',\n  status: 'closed',\n  canReStore: true\n});\n"})}),"\n",(0,i.jsx)(r.h3,{id:"price-triggers",children:"Price Triggers"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"PriceTrigger"})," executes actions when certain price levels are reached."]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Key Features:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Support for trigger directions (UpToDown, DownToUp)"}),"\n",(0,i.jsx)(r.li,{children:"Automatic direction detection based on current price"}),"\n",(0,i.jsx)(r.li,{children:"Performance optimization through min/max prices"}),"\n",(0,i.jsx)(r.li,{children:"Multiple symbol support"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Trigger Directions:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.code,{children:"UpToDown"})})," - triggers when price falls to specified level"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.code,{children:"DownToUp"})})," - triggers when price rises to specified level"]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Automatic Direction Selection:"}),"\nIf direction is not specified, the system automatically determines it based on current price:"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["If current price is ",(0,i.jsx)(r.strong,{children:"above"})," trigger price \u2192 ",(0,i.jsx)(r.code,{children:"UpToDown"})," is selected"]}),"\n",(0,i.jsxs)(r.li,{children:["If current price is ",(0,i.jsx)(r.strong,{children:"below"})," trigger price \u2192 ",(0,i.jsx)(r.code,{children:"DownToUp"})," is selected"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Usage Examples:"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-typescript",children:"import { PriceTriggerDirection } from 'jt-lib';\n\n// 1. Automatic direction selection\nglobals.triggers.addTaskByPrice({\n  symbol: 'BTC/USDT',\n  name: 'autoDirection',\n  triggerPrice: 50000, // Direction will be selected automatically\n  canReStore: true\n});\n\n// 2. Explicit direction - triggers on price rise\nglobals.triggers.addTaskByPrice({\n  symbol: 'BTC/USDT',\n  name: 'sellOnRise',\n  triggerPrice: 55000,\n  direction: PriceTriggerDirection.DownToUp, // Triggers on rise\n  canReStore: true\n});\n\n// 3. Explicit direction - triggers on price fall\nglobals.triggers.addTaskByPrice({\n  symbol: 'BTC/USDT',\n  name: 'buyOnFall',\n  triggerPrice: 45000,\n  direction: PriceTriggerDirection.UpToDown, // Triggers on fall\n  canReStore: true\n});\n\n// Register handlers\nglobals.triggers.registerPriceHandler('BTC/USDT', 'sellOnRise', this.onPriceRise, this);\nglobals.triggers.registerPriceHandler('BTC/USDT', 'buyOnFall', this.onPriceFall, this);\n"})}),"\n",(0,i.jsx)(r.h3,{id:"time-triggers",children:"Time Triggers"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"TimeTrigger"})," executes actions at specific times or with given intervals."]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Key Features:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Execute tasks at specific times"}),"\n",(0,i.jsx)(r.li,{children:"Recurring tasks with given intervals"}),"\n",(0,i.jsx)(r.li,{children:"Automatic trigger time validation"}),"\n",(0,i.jsx)(r.li,{children:"Warnings for incorrect time parameters"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Usage Examples:"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-typescript",children:"// Register handler\nglobals.triggers.registerTimeHandler('dailyReport', this.generateDailyReport, this);\n\n// Create task for specific time\nglobals.triggers.addTaskByTime({\n  name: 'dailyReport',\n  triggerTime: Date.now() + 24 * 60 * 60 * 1000, // tomorrow\n  canReStore: true\n});\n\n// Recurring task\nglobals.triggers.addTaskByTime({\n  name: 'hourlyCheck',\n  triggerTime: Date.now() + 60 * 60 * 1000, // in an hour\n  interval: 60 * 60 * 1000, // repeat every hour\n  canReStore: true\n});\n"})}),"\n",(0,i.jsx)(r.h2,{id:"trigger-storage-system",children:"Trigger Storage System"}),"\n",(0,i.jsx)(r.p,{children:"All triggers support automatic saving and restoration:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.code,{children:"canReStore: true"})})," - trigger will be saved to Storage"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Automatic Restoration"})," - when strategy restarts, triggers restore their state"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Persistence"})," - tasks continue working after restart"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"trigger-management",children:"Trigger Management"}),"\n",(0,i.jsx)(r.h3,{id:"handler-registration",children:"Handler Registration"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-typescript",children:"// Register handlers for all trigger types\nglobals.triggers.registerOrderHandler('taskName', this.handler, this);\nglobals.triggers.registerPriceHandler('BTC/USDT', 'taskName', this.handler, this);\nglobals.triggers.registerTimeHandler('taskName', this.handler, this);\n"})}),"\n",(0,i.jsx)(r.h3,{id:"task-creation",children:"Task Creation"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-typescript",children:"// Create tasks for each trigger type\nconst orderTaskId = globals.triggers.addTaskByOrder({...});\nconst priceTaskId = globals.triggers.addTaskByPrice({...});\nconst timeTaskId = globals.triggers.addTaskByTime({...});\n"})}),"\n",(0,i.jsx)(r.h3,{id:"task-cancellation",children:"Task Cancellation"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-typescript",children:"// Cancel specific task\nglobals.triggers.cancelOrderTask(orderTaskId);\nglobals.triggers.cancelPriceTask(priceTaskId);\nglobals.triggers.cancelTimeTask(timeTaskId);\n"})}),"\n",(0,i.jsx)(r.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,i.jsx)(r.h3,{id:"automatic-stop-loss-and-take-profit-management",children:"Automatic Stop Loss and Take Profit Management"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  async onInit() {\n    // Register handler for creating SL/TP\n    globals.triggers.registerOrderHandler('createSlTp', this.createSlTp, this);\n    \n    this.basket = new OrdersBasket({\n      symbol: this.symbols[0],\n      connectionName: this.connectionName\n    });\n    await this.basket.init();\n  }\n\n  async onTick() {\n    const price = this.basket.close();\n    \n    // Create order with automatic SL/TP\n    const order = await this.basket.buyMarket(\n      this.basket.getContractsAmount(100, price),\n      0, // SL will be set automatically\n      0  // TP will be set automatically\n    );\n\n    // Create task for automatic SL/TP creation\n    globals.triggers.addTaskByOrder({\n      name: 'createSlTp',\n      orderId: order.id,\n      status: 'closed', // will execute when order is filled\n      canReStore: true\n    });\n  }\n\n  async createSlTp(orderId: string) {\n    // Get order information\n    const order = await this.basket.getOrder(orderId);\n    \n    if (order && order.status === 'closed') {\n      const currentPrice = this.basket.close();\n      const slPrice = currentPrice * 0.95; // SL 5% below\n      const tpPrice = currentPrice * 1.1;  // TP 10% above\n      \n      // Create SL and TP orders\n      await this.basket.createStopLossOrder('buy', order.amount, slPrice);\n      await this.basket.createTakeProfitOrder('buy', order.amount, tpPrice);\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(r.h3,{id:"price-triggers-for-position-entry",children:"Price Triggers for Position Entry"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  async onInit() {\n    // Register handler for position entry\n    globals.triggers.registerPriceHandler('BTC/USDT', 'enterLong', this.enterLong, this);\n    globals.triggers.registerPriceHandler('BTC/USDT', 'enterShort', this.enterShort, this);\n    \n    this.basket = new OrdersBasket({\n      symbol: this.symbols[0],\n      connectionName: this.connectionName\n    });\n    await this.basket.init();\n    \n    const currentPrice = this.basket.close();\n    \n    // Create triggers for position entry\n    globals.triggers.addTaskByPrice({\n      symbol: 'BTC/USDT',\n      name: 'enterLong',\n      triggerPrice: currentPrice * 0.98, // entry 2% below current price\n      direction: 'DownToUp',\n      canReStore: true\n    });\n    \n    globals.triggers.addTaskByPrice({\n      symbol: 'BTC/USDT',\n      name: 'enterShort',\n      triggerPrice: currentPrice * 1.02, // entry 2% above current price\n      direction: 'UpToDown',\n      canReStore: true\n    });\n  }\n\n  async enterLong() {\n    const price = this.basket.close();\n    const contracts = this.basket.getContractsAmount(100, price);\n    \n    await this.basket.buyMarket(contracts, price * 0.95, price * 1.1);\n    log('PositionManager', 'Long position opened', { price, contracts }, true);\n  }\n\n  async enterShort() {\n    const price = this.basket.close();\n    const contracts = this.basket.getContractsAmount(100, price);\n    \n    await this.basket.sellMarket(contracts, price * 1.05, price * 0.9);\n    log('PositionManager', 'Short position opened', { price, contracts }, true);\n  }\n}\n"})}),"\n",(0,i.jsx)(r.h3,{id:"time-triggers-for-reports",children:"Time Triggers for Reports"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-typescript",children:"class Script extends BaseScript {\n  async onInit() {\n    // Register handler for daily reports\n    globals.triggers.registerTimeHandler('dailyReport', this.generateDailyReport, this);\n    globals.triggers.registerTimeHandler('hourlyCheck', this.hourlyCheck, this);\n    \n    this.basket = new OrdersBasket({\n      symbol: this.symbols[0],\n      connectionName: this.connectionName\n    });\n    await this.basket.init();\n    \n    // Create daily report at 00:00\n    const tomorrow = new Date();\n    tomorrow.setDate(tomorrow.getDate() + 1);\n    tomorrow.setHours(0, 0, 0, 0);\n    \n    globals.triggers.addTaskByTime({\n      name: 'dailyReport',\n      triggerTime: tomorrow.getTime(),\n      interval: 24 * 60 * 60 * 1000, // repeat every day\n      canReStore: true\n    });\n    \n    // Create hourly check\n    globals.triggers.addTaskByTime({\n      name: 'hourlyCheck',\n      triggerTime: Date.now() + 60 * 60 * 1000, // in an hour\n      interval: 60 * 60 * 1000, // repeat every hour\n      canReStore: true\n    });\n  }\n\n  async generateDailyReport() {\n    const positions = await this.basket.getPositions();\n    const orders = await this.basket.getOrders();\n    \n    log('DailyReport', '=== Daily Report ===', {}, true);\n    log('DailyReport', 'Positions count', { count: positions.length }, true);\n    log('DailyReport', 'Orders count', { count: orders.length }, true);\n    log('DailyReport', 'Current P&L', { pnl: positions.reduce((sum, pos) => sum + pos.unrealizedPnl, 0) }, true);\n  }\n\n  async hourlyCheck() {\n    const price = this.basket.close();\n    log('HourlyCheck', 'Hourly check - Current price', { price }, true);\n    \n    // Check trading conditions\n    if (price > 50000) {\n      log('HourlyCheck', 'Price above 50k - consider taking profit', { price }, true);\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(r.h2,{id:"integration-with-other-components",children:"Integration with Other Components"}),"\n",(0,i.jsx)(r.h3,{id:"triggerservice--eventemitter",children:"TriggerService + EventEmitter"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"TriggerService subscribes to events through EventEmitter"}),"\n",(0,i.jsx)(r.li,{children:"Automatic lifecycle synchronization"}),"\n",(0,i.jsx)(r.li,{children:"Full typing of all handlers"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"storage--triggers",children:"Storage + Triggers"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Triggers automatically save their state"}),"\n",(0,i.jsx)(r.li,{children:"When strategy restarts, state is restored"}),"\n",(0,i.jsx)(r.li,{children:"Ensures automation continuity"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"basescript--triggers",children:"BaseScript + Triggers"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Strategy registers trigger handlers"}),"\n",(0,i.jsx)(r.li,{children:"Automatic subscription management on destruction"}),"\n",(0,i.jsx)(r.li,{children:"Event system integration for automation"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/docs/jt-lib/events-system",children:"Event System"})})," - EventEmitter for event management"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/docs/jt-lib/trading-scripts",children:"Trading Scripts"})})," - Base class for trading scripts"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/docs/jt-lib/exchange-orders-basket",children:"Exchange Operations"})})," - OrdersBasket for trading operations"]}),"\n"]})]})}function d(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>c});var t=n(6540);const i={},s=t.createContext(i);function a(e){const r=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);